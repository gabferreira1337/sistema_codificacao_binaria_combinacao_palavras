<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>projeto_lp1_aed1: functions/functions_1.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">projeto_lp1_aed1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_35baea09d55bebfe17654fdf4bf061ce.html">functions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">functions_1.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
</div>
<p><a href="functions__1_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_e_t_s.html">SETS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets struct  <a href="struct_s_e_t_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_f_p6.html">UFP6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash table.  <a href="struct_u_f_p6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold Hash table.  <a href="struct_h_a_s_h_t_a_b_l_e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9d2a7c69bd3fabc41e1ee87df2f283b3" id="r_a9d2a7c69bd3fabc41e1ee87df2f283b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a9d2a7c69bd3fabc41e1ee87df2f283b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd5ad0509017bf3449ca26c2a873684" id="r_a0cd5ad0509017bf3449ca26c2a873684"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cd5ad0509017bf3449ca26c2a873684">MAX_UFP6</a>&#160;&#160;&#160;62</td></tr>
<tr class="separator:a0cd5ad0509017bf3449ca26c2a873684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534ad31d9e306202c071ae3c21eaf50a" id="r_a534ad31d9e306202c071ae3c21eaf50a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a534ad31d9e306202c071ae3c21eaf50a">RADIX</a>&#160;&#160;&#160;62</td></tr>
<tr class="separator:a534ad31d9e306202c071ae3c21eaf50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd52d14d1bcb67d6a1410faeced2290" id="r_a7bd52d14d1bcb67d6a1410faeced2290"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bd52d14d1bcb67d6a1410faeced2290">M_KMP</a>&#160;&#160;&#160;<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a></td></tr>
<tr class="separator:a7bd52d14d1bcb67d6a1410faeced2290"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6f716ebc0f8778349c9fabb8de345d12" id="r_a6f716ebc0f8778349c9fabb8de345d12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f716ebc0f8778349c9fabb8de345d12">sets_struct_init</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int *sizes_ufp6, int number_words)</td></tr>
<tr class="separator:a6f716ebc0f8778349c9fabb8de345d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebe7cf56667e0677705a189555c02b5" id="r_aaebe7cf56667e0677705a189555c02b5"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaebe7cf56667e0677705a189555c02b5">gen_rnd_char</a> ()</td></tr>
<tr class="separator:aaebe7cf56667e0677705a189555c02b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543fffbd4a9930e508c8ae1a43ee9759" id="r_a543fffbd4a9930e508c8ae1a43ee9759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a543fffbd4a9930e508c8ae1a43ee9759">matrix_rnd_word_gen</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a543fffbd4a9930e508c8ae1a43ee9759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09aa42b969c4795fd0f055b0631d34f1" id="r_a09aa42b969c4795fd0f055b0631d34f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09aa42b969c4795fd0f055b0631d34f1">matrix_ufp6_init</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int *sizes_ufp6_char)</td></tr>
<tr class="separator:a09aa42b969c4795fd0f055b0631d34f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775cb511b6aa690291a4c915d671e633" id="r_a775cb511b6aa690291a4c915d671e633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a775cb511b6aa690291a4c915d671e633">matrix_init_char</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a775cb511b6aa690291a4c915d671e633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31931eb9ac464b81089df00fa9fb1232" id="r_a31931eb9ac464b81089df00fa9fb1232"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31931eb9ac464b81089df00fa9fb1232">init_arr_word_size</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a31931eb9ac464b81089df00fa9fb1232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26edb02e573505a164e1ea18d9931909" id="r_a26edb02e573505a164e1ea18d9931909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26edb02e573505a164e1ea18d9931909">init_arr_ufp6_size</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a26edb02e573505a164e1ea18d9931909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f9da439fadfce30edfde1dc4ba9992" id="r_a82f9da439fadfce30edfde1dc4ba9992"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82f9da439fadfce30edfde1dc4ba9992">print_matrix_int</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a82f9da439fadfce30edfde1dc4ba9992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0c8623bd8287e75f13fabc4b7ee657" id="r_a8e0c8623bd8287e75f13fabc4b7ee657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e0c8623bd8287e75f13fabc4b7ee657">rnd_word_size_gen</a> (int *arr, int W)</td></tr>
<tr class="separator:a8e0c8623bd8287e75f13fabc4b7ee657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3798ad42a105dc2af7d64086d4833635" id="r_a3798ad42a105dc2af7d64086d4833635"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3798ad42a105dc2af7d64086d4833635">insert_word_char</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char *word, int index)</td></tr>
<tr class="separator:a3798ad42a105dc2af7d64086d4833635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260f22e58c106f02faa708e288c818d7" id="r_a260f22e58c106f02faa708e288c818d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a260f22e58c106f02faa708e288c818d7">insert_ufp6</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int sizes_ufp6_dict[], const int ufp6_dict[][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1], const char *word, int index)</td></tr>
<tr class="separator:a260f22e58c106f02faa708e288c818d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa1e8d78680fb71f3c461f7dff33d67" id="r_a3aa1e8d78680fb71f3c461f7dff33d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa1e8d78680fb71f3c461f7dff33d67">matrix_encode_realloc</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a3aa1e8d78680fb71f3c461f7dff33d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110db8dd6cf62040e412364f2ab739d7" id="r_a110db8dd6cf62040e412364f2ab739d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a110db8dd6cf62040e412364f2ab739d7">insert_words</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char **words, const int *sizes_ufp6_dict, const int ufp6_dict[][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1], int num_words)</td></tr>
<tr class="separator:a110db8dd6cf62040e412364f2ab739d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2596fe0f67cdebbd782f6bca8d8707" id="r_ada2596fe0f67cdebbd782f6bca8d8707"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada2596fe0f67cdebbd782f6bca8d8707">print_arr_word_size</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:ada2596fe0f67cdebbd782f6bca8d8707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca37c925b0491d48070ed7d34ea7d16" id="r_abca37c925b0491d48070ed7d34ea7d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abca37c925b0491d48070ed7d34ea7d16">print_matrix_char</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:abca37c925b0491d48070ed7d34ea7d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65bdf4578c29e7408ec45566295b9c9" id="r_af65bdf4578c29e7408ec45566295b9c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af65bdf4578c29e7408ec45566295b9c9">calc_ufp6_size</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int index, const char *word, const int *sizes_ufp6)</td></tr>
<tr class="separator:af65bdf4578c29e7408ec45566295b9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302db3993a889fcea336cf60ae2e5469" id="r_a302db3993a889fcea336cf60ae2e5469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a302db3993a889fcea336cf60ae2e5469">freemem_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a302db3993a889fcea336cf60ae2e5469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c6840cbc2b232c18831c8ff94be3ec" id="r_a53c6840cbc2b232c18831c8ff94be3ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53c6840cbc2b232c18831c8ff94be3ec">msdRadixSort</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int *array_sizes_ufp6, int lo, int hi, bool flag)</td></tr>
<tr class="separator:a53c6840cbc2b232c18831c8ff94be3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cedd8eeb4742c5687b4eeb7ceed506a" id="r_a0cedd8eeb4742c5687b4eeb7ceed506a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cedd8eeb4742c5687b4eeb7ceed506a">msdRadixSort_r</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, char **aux, int **aux_ufp6, const int *array_sizes_ufp6, int lo, int hi, int d, bool flag)</td></tr>
<tr class="separator:a0cedd8eeb4742c5687b4eeb7ceed506a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aec849b74f8bf7ff34034b534e171a" id="r_a40aec849b74f8bf7ff34034b534e171a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40aec849b74f8bf7ff34034b534e171a">sort_size</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, bool flag)</td></tr>
<tr class="separator:a40aec849b74f8bf7ff34034b534e171a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614b865a44ccba94c91a247e564d3f3e" id="r_a614b865a44ccba94c91a247e564d3f3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a614b865a44ccba94c91a247e564d3f3e">q_sort</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int *arr, int lo, int hi, bool flag)</td></tr>
<tr class="separator:a614b865a44ccba94c91a247e564d3f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e7df9550bc0449a14451851a9855dc" id="r_a94e7df9550bc0449a14451851a9855dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e7df9550bc0449a14451851a9855dc">partition</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int *arr, int lo, int hi, bool flag)</td></tr>
<tr class="separator:a94e7df9550bc0449a14451851a9855dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e471a0a35b34bd4905003f9ea0cb919" id="r_a0e471a0a35b34bd4905003f9ea0cb919"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e471a0a35b34bd4905003f9ea0cb919">findMedian</a> (const int *arr, int lo, int mid, int hi)</td></tr>
<tr class="separator:a0e471a0a35b34bd4905003f9ea0cb919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab136cadda6cd8ca4f7610085182fe23d" id="r_ab136cadda6cd8ca4f7610085182fe23d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab136cadda6cd8ca4f7610085182fe23d">knuth_shuffle</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:ab136cadda6cd8ca4f7610085182fe23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1330d54bcd4ea316647d71670388d795" id="r_a1330d54bcd4ea316647d71670388d795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1330d54bcd4ea316647d71670388d795">exch</a> (int *arr, int i, int j)</td></tr>
<tr class="separator:a1330d54bcd4ea316647d71670388d795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e49216f9942802fbec2e6744d402139" id="r_a6e49216f9942802fbec2e6744d402139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e49216f9942802fbec2e6744d402139">ufp6_dictionary</a> (int ufp6_dict[][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1], int *size_ufp6)</td></tr>
<tr class="separator:a6e49216f9942802fbec2e6744d402139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac787f7c2907123f7a3a9b4026225a342" id="r_ac787f7c2907123f7a3a9b4026225a342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac787f7c2907123f7a3a9b4026225a342">print_ufp6_dictionary</a> (int bin_dict[][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1], int *size_ufp6)</td></tr>
<tr class="separator:ac787f7c2907123f7a3a9b4026225a342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44131f42fbfc8732c48223cefbc89f2b" id="r_a44131f42fbfc8732c48223cefbc89f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44131f42fbfc8732c48223cefbc89f2b">encode_matrix_words</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int sizes_ufp6_dict[], int ufp6_dict[][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1])</td></tr>
<tr class="separator:a44131f42fbfc8732c48223cefbc89f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622b72396e32a32e0e20af721f789b19" id="r_a622b72396e32a32e0e20af721f789b19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a622b72396e32a32e0e20af721f789b19">charToUFP6</a> (int c, int *result, int numBits_ufp6_char)</td></tr>
<tr class="separator:a622b72396e32a32e0e20af721f789b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28b1955ef487fec8b1e7de5abc8a61d" id="r_ac28b1955ef487fec8b1e7de5abc8a61d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac28b1955ef487fec8b1e7de5abc8a61d">fperror</a> (char *message)</td></tr>
<tr class="separator:ac28b1955ef487fec8b1e7de5abc8a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2933044bef3e1e95cbdb3337b295933" id="r_ab2933044bef3e1e95cbdb3337b295933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2933044bef3e1e95cbdb3337b295933">encode_word</a> (const char *word, int *encode, int *word_ufp6_size, int k, const int sizes_ufp6[], const int ufp6_dict[][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1], int W)</td></tr>
<tr class="separator:ab2933044bef3e1e95cbdb3337b295933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f1fdfb3975b127b84ac4318b49227" id="r_a227f1fdfb3975b127b84ac4318b49227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a227f1fdfb3975b127b84ac4318b49227">combination_ufp6_in_both_sets</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set2, int size)</td></tr>
<tr class="separator:a227f1fdfb3975b127b84ac4318b49227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2ea41700a6f804f3c6837293ffe697" id="r_a0e2ea41700a6f804f3c6837293ffe697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e2ea41700a6f804f3c6837293ffe697">generate_permutations_ufp6</a> (<a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *hash_table, char *a, int l, int r, int flag)</td></tr>
<tr class="separator:a0e2ea41700a6f804f3c6837293ffe697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501783d4e0fcd599169d15cbf6f60494" id="r_a501783d4e0fcd599169d15cbf6f60494"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a501783d4e0fcd599169d15cbf6f60494">init_hash_table</a> (<a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> **hash_table, int size, int count)</td></tr>
<tr class="memdesc:a501783d4e0fcd599169d15cbf6f60494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize hash table pointers to NULL.  <br /></td></tr>
<tr class="separator:a501783d4e0fcd599169d15cbf6f60494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b15ac06834cc52f8b3ab90bd128513" id="r_a69b15ac06834cc52f8b3ab90bd128513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69b15ac06834cc52f8b3ab90bd128513">print_table</a> (<a class="el" href="struct_u_f_p6.html">UFP6</a> **hash_table)</td></tr>
<tr class="separator:a69b15ac06834cc52f8b3ab90bd128513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823382a2c216d33a2634cd902ce1a636" id="r_a823382a2c216d33a2634cd902ce1a636"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a823382a2c216d33a2634cd902ce1a636">hash</a> (const char *ufp6_encode, int size)</td></tr>
<tr class="separator:a823382a2c216d33a2634cd902ce1a636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a336db3b6b692d215cd3631fd86e48" id="r_a60a336db3b6b692d215cd3631fd86e48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a336db3b6b692d215cd3631fd86e48">hash_table_insert</a> (<a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *hash_table, <a class="el" href="struct_u_f_p6.html">UFP6</a> *new)</td></tr>
<tr class="separator:a60a336db3b6b692d215cd3631fd86e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fad50f639741bbad440dddfb3c992e" id="r_a73fad50f639741bbad440dddfb3c992e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73fad50f639741bbad440dddfb3c992e">rehash</a> (<a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> **hash_table, int size)</td></tr>
<tr class="memdesc:a73fad50f639741bbad440dddfb3c992e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to rehash the elements from the old hash table to the new one.  <br /></td></tr>
<tr class="separator:a73fad50f639741bbad440dddfb3c992e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ecf5fb92d7dc3e3191d1c9a561a457" id="r_ae2ecf5fb92d7dc3e3191d1c9a561a457"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2ecf5fb92d7dc3e3191d1c9a561a457">swapc</a> (char *x, char *y)</td></tr>
<tr class="separator:ae2ecf5fb92d7dc3e3191d1c9a561a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aeb349ef801ce1d964a32667cce2cd0" id="r_a9aeb349ef801ce1d964a32667cce2cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_u_f_p6.html">UFP6</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aeb349ef801ce1d964a32667cce2cd0">hash_table_lookup</a> (<a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *hash_table, char *ufp6)</td></tr>
<tr class="memdesc:a9aeb349ef801ce1d964a32667cce2cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">chech if value is in hash table  <br /></td></tr>
<tr class="separator:a9aeb349ef801ce1d964a32667cce2cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb1b2bd89ee16b9b07c7913014d2b7a" id="r_a9cb1b2bd89ee16b9b07c7913014d2b7a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb1b2bd89ee16b9b07c7913014d2b7a">matrix_to_string</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a9cb1b2bd89ee16b9b07c7913014d2b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b71cc307a1637aae2aef3ed391239" id="r_af43b71cc307a1637aae2aef3ed391239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af43b71cc307a1637aae2aef3ed391239">insert_new_UFP6_node</a> (<a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *hash_table, const char *str, int size, int flag)</td></tr>
<tr class="separator:af43b71cc307a1637aae2aef3ed391239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5067ad978808fe928273bd9ab1c064" id="r_acf5067ad978808fe928273bd9ab1c064"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf5067ad978808fe928273bd9ab1c064">calculate_decimal_size</a> (int num)</td></tr>
<tr class="separator:acf5067ad978808fe928273bd9ab1c064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd323584c5100968802d3d5b9e449ef" id="r_a8cd323584c5100968802d3d5b9e449ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cd323584c5100968802d3d5b9e449ef">print_combinations_found</a> (<a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *hash_table, int size)</td></tr>
<tr class="separator:a8cd323584c5100968802d3d5b9e449ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8118fa3cb7085214c19b2de21e83642f" id="r_a8118fa3cb7085214c19b2de21e83642f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8118fa3cb7085214c19b2de21e83642f">free_hash_table</a> (<a class="el" href="struct_u_f_p6.html">UFP6</a> **hash_table)</td></tr>
<tr class="separator:a8118fa3cb7085214c19b2de21e83642f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893c09ccffd2b29d0b2d4bfa3a15d1c6" id="r_a893c09ccffd2b29d0b2d4bfa3a15d1c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a893c09ccffd2b29d0b2d4bfa3a15d1c6">less</a> (char *str1, char *str2, int d, bool flag)</td></tr>
<tr class="separator:a893c09ccffd2b29d0b2d4bfa3a15d1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad2da8aa7f668f406b118d171c2ab33" id="r_a2ad2da8aa7f668f406b118d171c2ab33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ad2da8aa7f668f406b118d171c2ab33">insertion_sort</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int lo, int hi, int d, bool flag)</td></tr>
<tr class="separator:a2ad2da8aa7f668f406b118d171c2ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0778c149f5b7fe28e3fb9228a2ea5ef7" id="r_a0778c149f5b7fe28e3fb9228a2ea5ef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0778c149f5b7fe28e3fb9228a2ea5ef7">insertion_sort_int</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int lo, int hi, bool flag)</td></tr>
<tr class="separator:a0778c149f5b7fe28e3fb9228a2ea5ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d756a5798bf2b718ea13ff39576ca32" id="r_a6d756a5798bf2b718ea13ff39576ca32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d756a5798bf2b718ea13ff39576ca32">sort_by_alphabetical_order</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int *sizes_ufp6, bool flag)</td></tr>
<tr class="separator:a6d756a5798bf2b718ea13ff39576ca32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07bf10286bd75f8ad3d26951df189a0" id="r_ae07bf10286bd75f8ad3d26951df189a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae07bf10286bd75f8ad3d26951df189a0">merge</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, char **aux_matrix, int **aux_matrix_ufp6, int lo, int mid, int hi, bool flag)</td></tr>
<tr class="separator:ae07bf10286bd75f8ad3d26951df189a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26594aedef0cae2d575940358861c1c0" id="r_a26594aedef0cae2d575940358861c1c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26594aedef0cae2d575940358861c1c0">sort</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, char **aux_matrix, int **aux_matrix_ufp6, int lo, int hi, bool flag)</td></tr>
<tr class="separator:a26594aedef0cae2d575940358861c1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae848a36a8bac106333cbaec3fd1a3af3" id="r_ae848a36a8bac106333cbaec3fd1a3af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae848a36a8bac106333cbaec3fd1a3af3">KMP</a> (const char pattern[<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1], int dfa[<a class="el" href="#a0cd5ad0509017bf3449ca26c2a873684">MAX_UFP6</a>][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1])</td></tr>
<tr class="separator:ae848a36a8bac106333cbaec3fd1a3af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61afcd9bd1d43eb70bc58a14f93fc8e9" id="r_a61afcd9bd1d43eb70bc58a14f93fc8e9"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61afcd9bd1d43eb70bc58a14f93fc8e9">search_KMP</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int dfa[<a class="el" href="#a0cd5ad0509017bf3449ca26c2a873684">MAX_UFP6</a>][<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a> - 1], int pattern_length)</td></tr>
<tr class="separator:a61afcd9bd1d43eb70bc58a14f93fc8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607b9ff36242aa00e078ce5367080334" id="r_a607b9ff36242aa00e078ce5367080334"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a607b9ff36242aa00e078ce5367080334">print_kmp</a> (int dfa[<a class="el" href="#a0cd5ad0509017bf3449ca26c2a873684">MAX_UFP6</a>][<a class="el" href="#a7bd52d14d1bcb67d6a1410faeced2290">M_KMP</a>])</td></tr>
<tr class="separator:a607b9ff36242aa00e078ce5367080334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f6add36c9ceff9594842c6aca6419e" id="r_a12f6add36c9ceff9594842c6aca6419e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12f6add36c9ceff9594842c6aca6419e">print_found_words_and_ufp6</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int *array_index)</td></tr>
<tr class="separator:a12f6add36c9ceff9594842c6aca6419e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a8628d8e64a7efc1587cc2db96ad16" id="r_aa3a8628d8e64a7efc1587cc2db96ad16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3a8628d8e64a7efc1587cc2db96ad16">find_words_with_pattern</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char **patterns, int W, const char *fn, bool flag)</td></tr>
<tr class="separator:aa3a8628d8e64a7efc1587cc2db96ad16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae498d9c29c8a58e05dea42441315f4f5" id="r_ae498d9c29c8a58e05dea42441315f4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae498d9c29c8a58e05dea42441315f4f5">remove_word_from_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int index_remove)</td></tr>
<tr class="separator:ae498d9c29c8a58e05dea42441315f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac068fd70ca26d3588ec24f10c75cdac5" id="r_ac068fd70ca26d3588ec24f10c75cdac5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac068fd70ca26d3588ec24f10c75cdac5">find_word_in_set_and_remove</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char *word)</td></tr>
<tr class="separator:ac068fd70ca26d3588ec24f10c75cdac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a7342ea8b1f0361d9335b2b51a5c18" id="r_a14a7342ea8b1f0361d9335b2b51a5c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14a7342ea8b1f0361d9335b2b51a5c18">remove_Words</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char **words, int W)</td></tr>
<tr class="separator:a14a7342ea8b1f0361d9335b2b51a5c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bcd1312c981361d828815983a2b5e3" id="r_a47bcd1312c981361d828815983a2b5e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47bcd1312c981361d828815983a2b5e3">find_word_with_pattern</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char *pattern, int **array_index)</td></tr>
<tr class="separator:a47bcd1312c981361d828815983a2b5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7feb79ca6d753d9f80a5d0a5c27062fb" id="r_a7feb79ca6d753d9f80a5d0a5c27062fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7feb79ca6d753d9f80a5d0a5c27062fb">remove_UFP6</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int index)</td></tr>
<tr class="separator:a7feb79ca6d753d9f80a5d0a5c27062fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47976eaf9c7739c630c11b2045cd6e5f" id="r_a47976eaf9c7739c630c11b2045cd6e5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47976eaf9c7739c630c11b2045cd6e5f">realloc_row_remove</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int row)</td></tr>
<tr class="separator:a47976eaf9c7739c630c11b2045cd6e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af442e3a0b833c51fa45ec9160f914279" id="r_af442e3a0b833c51fa45ec9160f914279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af442e3a0b833c51fa45ec9160f914279">compute_words_size</a> (const char **words, int *words_index, int W)</td></tr>
<tr class="separator:af442e3a0b833c51fa45ec9160f914279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559b2b2f6d280317ba8b42593ed42496" id="r_a559b2b2f6d280317ba8b42593ed42496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a559b2b2f6d280317ba8b42593ed42496">realloc_arr_words_size</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a559b2b2f6d280317ba8b42593ed42496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ed21ac12ea5242ab349ee86f219745" id="r_a53ed21ac12ea5242ab349ee86f219745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53ed21ac12ea5242ab349ee86f219745">realloc_arr_ufp6_size</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set)</td></tr>
<tr class="separator:a53ed21ac12ea5242ab349ee86f219745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fc561bcd9ebec14151a55c9861e1ed" id="r_af7fc561bcd9ebec14151a55c9861e1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7fc561bcd9ebec14151a55c9861e1ed">realloc_rows_matrix</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int num_words)</td></tr>
<tr class="separator:af7fc561bcd9ebec14151a55c9861e1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9a4ecbbf9465d2e04789b05fe3ee55" id="r_a1a9a4ecbbf9465d2e04789b05fe3ee55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a9a4ecbbf9465d2e04789b05fe3ee55">realloc_rows_ufp6</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int num_words)</td></tr>
<tr class="separator:a1a9a4ecbbf9465d2e04789b05fe3ee55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29705aa52acf5a708e189bb56665cee7" id="r_a29705aa52acf5a708e189bb56665cee7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29705aa52acf5a708e189bb56665cee7">realloc_col_word</a> (char **mat_row, int col_words_size)</td></tr>
<tr class="separator:a29705aa52acf5a708e189bb56665cee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e25de36ac5cdb54a677792e9eccccc9" id="r_a4e25de36ac5cdb54a677792e9eccccc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e25de36ac5cdb54a677792e9eccccc9">realloc_col_ufp6</a> (int **mat_row, int col_words_size)</td></tr>
<tr class="separator:a4e25de36ac5cdb54a677792e9eccccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f1b700391b53977f4128f0217f6253" id="r_a90f1b700391b53977f4128f0217f6253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f1b700391b53977f4128f0217f6253">calloc_matrix_words_and_ufp6</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int num_words)</td></tr>
<tr class="separator:a90f1b700391b53977f4128f0217f6253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4b07296f3ee56927ac1f72981f36de" id="r_a2b4b07296f3ee56927ac1f72981f36de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b4b07296f3ee56927ac1f72981f36de">calculate_index_char</a> (char currentChar, bool flag)</td></tr>
<tr class="separator:a2b4b07296f3ee56927ac1f72981f36de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf01e02d804416c09fa3e7c15698d8d9" id="r_acf01e02d804416c09fa3e7c15698d8d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf01e02d804416c09fa3e7c15698d8d9">is_ufp6</a> (const char *word, int W)</td></tr>
<tr class="separator:acf01e02d804416c09fa3e7c15698d8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e8dd180d70e127b409dbb543b5a8b8" id="r_a41e8dd180d70e127b409dbb543b5a8b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41e8dd180d70e127b409dbb543b5a8b8">seed_random</a> ()</td></tr>
<tr class="memdesc:a41e8dd180d70e127b409dbb543b5a8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">clock function to measure processor time and use as a seed  <br /></td></tr>
<tr class="separator:a41e8dd180d70e127b409dbb543b5a8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbd6f856771294de0d4979da04d627f" id="r_a6fbd6f856771294de0d4979da04d627f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6fbd6f856771294de0d4979da04d627f">exch_rows_matrix_char</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int i, int j)</td></tr>
<tr class="separator:a6fbd6f856771294de0d4979da04d627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaa0fe3dd45f8a8445613a4bccf15b8" id="r_a3aaa0fe3dd45f8a8445613a4bccf15b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aaa0fe3dd45f8a8445613a4bccf15b8">exch_rows_matrix_ufp6</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int i, int j)</td></tr>
<tr class="separator:a3aaa0fe3dd45f8a8445613a4bccf15b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63ac05bfffb294b6a73a1426e276b75" id="r_ae63ac05bfffb294b6a73a1426e276b75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63ac05bfffb294b6a73a1426e276b75">exch_rows_from_both_matrix</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int i, int j)</td></tr>
<tr class="separator:ae63ac05bfffb294b6a73a1426e276b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2798f10e7e1b18c4e19cd5f71f220c" id="r_a7a2798f10e7e1b18c4e19cd5f71f220c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2798f10e7e1b18c4e19cd5f71f220c">is_sorted_matrix</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int N, bool flag)</td></tr>
<tr class="separator:a7a2798f10e7e1b18c4e19cd5f71f220c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab4a064e55c0a607c89f4ae31a75f0c" id="r_a9ab4a064e55c0a607c89f4ae31a75f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ab4a064e55c0a607c89f4ae31a75f0c">is_sorted_sizes</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int N, bool flag)</td></tr>
<tr class="separator:a9ab4a064e55c0a607c89f4ae31a75f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2658bb62abcb857deeee53ab7fd48423" id="r_a2658bb62abcb857deeee53ab7fd48423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2658bb62abcb857deeee53ab7fd48423">check_words_supported_UFP6</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, char **words, int W, int *prev_num_words)</td></tr>
<tr class="separator:a2658bb62abcb857deeee53ab7fd48423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd0c8603cd35f4ae9f2e5fbc5f51125" id="r_a2cd0c8603cd35f4ae9f2e5fbc5f51125"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cd0c8603cd35f4ae9f2e5fbc5f51125">calculate_sizes_words_and_ufp6_from_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int *sizes_ufp6)</td></tr>
<tr class="separator:a2cd0c8603cd35f4ae9f2e5fbc5f51125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215f3c8abe9fe5b82585ea4d53ae70d8" id="r_a215f3c8abe9fe5b82585ea4d53ae70d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a215f3c8abe9fe5b82585ea4d53ae70d8">write_to_txt_benchmark_sorting</a> (char *fn, float time_delta_merge_s, float time_delta_msd, unsigned long number_words)</td></tr>
<tr class="separator:a215f3c8abe9fe5b82585ea4d53ae70d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb63e36b244b737f8f6140ca04bb96e" id="r_afbb63e36b244b737f8f6140ca04bb96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb63e36b244b737f8f6140ca04bb96e">read_words_from_txt_to_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp, const int *sizes_ufp6)</td></tr>
<tr class="separator:afbb63e36b244b737f8f6140ca04bb96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3af03ebc5906c9a52d48745f2e0a5db" id="r_ae3af03ebc5906c9a52d48745f2e0a5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3af03ebc5906c9a52d48745f2e0a5db">read_words_from_txt</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char *fn, const int *sizes_ufp6)</td></tr>
<tr class="separator:ae3af03ebc5906c9a52d48745f2e0a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9d2a7c69bd3fabc41e1ee87df2f283b3" name="a9d2a7c69bd3fabc41e1ee87df2f283b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">&#9670;&#160;</a></span>BITS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BITS&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bd52d14d1bcb67d6a1410faeced2290" name="a7bd52d14d1bcb67d6a1410faeced2290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd52d14d1bcb67d6a1410faeced2290">&#9670;&#160;</a></span>M_KMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define M_KMP&#160;&#160;&#160;<a class="el" href="#a9d2a7c69bd3fabc41e1ee87df2f283b3">BITS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cd5ad0509017bf3449ca26c2a873684" name="a0cd5ad0509017bf3449ca26c2a873684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd5ad0509017bf3449ca26c2a873684">&#9670;&#160;</a></span>MAX_UFP6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_UFP6&#160;&#160;&#160;62</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a534ad31d9e306202c071ae3c21eaf50a" name="a534ad31d9e306202c071ae3c21eaf50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534ad31d9e306202c071ae3c21eaf50a">&#9670;&#160;</a></span>RADIX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RADIX&#160;&#160;&#160;62</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af65bdf4578c29e7408ec45566295b9c9" name="af65bdf4578c29e7408ec45566295b9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65bdf4578c29e7408ec45566295b9c9">&#9670;&#160;</a></span>calc_ufp6_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calc_ufp6_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>word</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Function"></a>
to calculate UFP6 representation of all words and store in</h4>
<p>set arr_ufp6_size at a given index Time Complexity: O(W) = length of word Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">index</td><td>- index of word to store the <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> size </td></tr>
    <tr><td class="paramname">word</td><td>- pointer to word </td></tr>
    <tr><td class="paramname">sizes_ufp6</td><td>- pointer to pre-computed array with all sizes of each char supported in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> </td></tr>
  </table>
  </dd>
</dl>
<p>Check if the character is a valid key in dictionary</p>
<p>Store the size of each word</p>

</div>
</div>
<a id="acf5067ad978808fe928273bd9ab1c064" name="acf5067ad978808fe928273bd9ab1c064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5067ad978808fe928273bd9ab1c064">&#9670;&#160;</a></span>calculate_decimal_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int calculate_decimal_size </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>has 1 digit</p>
<p>Divide by 10 to remove the last digit</p>

</div>
</div>
<a id="a2b4b07296f3ee56927ac1f72981f36de" name="a2b4b07296f3ee56927ac1f72981f36de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4b07296f3ee56927ac1f72981f36de">&#9670;&#160;</a></span>calculate_index_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int calculate_index_char </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>currentChar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if char is supported in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>
<p>Calculate in ASC order</p>
<p>Reverse subtraction to calculate index in DESC order</p>
<p>If char is not supported return -1</p>

</div>
</div>
<a id="a2cd0c8603cd35f4ae9f2e5fbc5f51125" name="a2cd0c8603cd35f4ae9f2e5fbc5f51125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd0c8603cd35f4ae9f2e5fbc5f51125">&#9670;&#160;</a></span>calculate_sizes_words_and_ufp6_from_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculate_sizes_words_and_ufp6_from_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>in arr_word_size and arr_ufp6_size from <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct Time Complexity: O(N) N = number of rows in matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">sizes_ufp6</td><td>- pointer to array holding sizes of pre-computed <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representations of each char </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90f1b700391b53977f4128f0217f6253" name="a90f1b700391b53977f4128f0217f6253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f1b700391b53977f4128f0217f6253">&#9670;&#160;</a></span>calloc_matrix_words_and_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calloc_matrix_words_and_ufp6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a622b72396e32a32e0e20af721f789b19" name="a622b72396e32a32e0e20af721f789b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622b72396e32a32e0e20af721f789b19">&#9670;&#160;</a></span>charToUFP6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void charToUFP6 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>c</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>result</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numBits_ufp6_char</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Convert"></a>
char into UFP6 filling array in reverse order into Dictionary</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>- char to be converted </td></tr>
    <tr><td class="paramname">result</td><td>- pointer to array to store the result of each conversion </td></tr>
    <tr><td class="paramname">size_bin</td><td>- pointer to an array with pre-computed sizes_uf6 </td></tr>
  </table>
  </dd>
</dl>
<p>Use numBits_ufp6_char to only store the right size of bits of each value Convert filling array in reverse order</p>
<p>c &gt;&gt; i = right-shifts the bits of c by i times Moving the bit at position i to the least significant bit (LSB). (c &gt;&gt; i) &amp; 1 = bitwise AND with 1. Extracting the least significant bit (LSB) after the right shift, checking whether the bit at position i is 0 or 1.</p>

</div>
</div>
<a id="a2658bb62abcb857deeee53ab7fd48423" name="a2658bb62abcb857deeee53ab7fd48423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2658bb62abcb857deeee53ab7fd48423">&#9670;&#160;</a></span>check_words_supported_UFP6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_words_supported_UFP6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>words</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>prev_num_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>if not supported in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> set to NULL pointer to word and update prev_num_words supported if supported update row size of both matrix to after reallocate them Time Complexity: O(W) Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">words</td><td>- pointer to array of strings (words) </td></tr>
    <tr><td class="paramname">W</td><td>- size of words </td></tr>
    <tr><td class="paramname">prev_num_words</td><td>- variable to store the size of strings supported in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> </td></tr>
  </table>
  </dd>
</dl>
<p>Check if words to be inserted are supported in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>

</div>
</div>
<a id="a227f1fdfb3975b127b84ac4318b49227" name="a227f1fdfb3975b127b84ac4318b49227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227f1fdfb3975b127b84ac4318b49227">&#9670;&#160;</a></span>combination_ufp6_in_both_sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void combination_ufp6_in_both_sets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Find"></a>
median between arr[lo], arr[mid] and arr[hi]</h4>
<p>Backtracking method and a dynamic Hash Table to store and check equal combinations by holding a flag (repeated) if greater than 1 and has a odd value it means that combination appeared in both sets Time Complexity: O (M + 2( R * BITS - 1 ) + (p!) + N) M = init Hash table (R * Bits - 1) parse matrix to string p! = size of permutations N = Reashing hash table Extra Space: O (M + L + S) M = size of hash table L = length of string1 S = length of string2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set1</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">set2</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">size</td><td>- size of combination </td></tr>
  </table>
  </dd>
</dl>
<p>Convert both Matrix <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> to array</p>
<p>If size of string greater than size of combination</p>
<p>Generate and search for equal combinations between both sets</p>
<p>If number of elements in hash table is greater than 4 times hash table Execute reashing copying data to a new hash table of 4 times the size</p>

</div>
</div>
<a id="af442e3a0b833c51fa45ec9160f914279" name="af442e3a0b833c51fa45ec9160f914279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af442e3a0b833c51fa45ec9160f914279">&#9670;&#160;</a></span>compute_words_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_words_size </td>
          <td>(</td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>words</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>words_index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Calculates"></a>
the size of W words and places the result in the array words_index</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>- array with the words </td></tr>
    <tr><td class="paramname">words_index</td><td>-pointer to an array that will contain the sizes of words </td></tr>
    <tr><td class="paramname">W</td><td>- size of words </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44131f42fbfc8732c48223cefbc89f2b" name="a44131f42fbfc8732c48223cefbc89f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44131f42fbfc8732c48223cefbc89f2b">&#9670;&#160;</a></span>encode_matrix_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_matrix_words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6_dict</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ufp6_dict</em>[][BITS - 1]</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>encode_word function to encode each word into matrix_ufp6 in set Time complexity: O (N (W * M)) N = size of words W = length of each word M = <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> size representation Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">sizes_ufp6_dict</td><td>- array with ufp6 sizes of each char </td></tr>
    <tr><td class="paramname">ufp6_dict</td><td>- pre-computed dictionary with <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2933044bef3e1e95cbdb3337b295933" name="ab2933044bef3e1e95cbdb3337b295933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2933044bef3e1e95cbdb3337b295933">&#9670;&#160;</a></span>encode_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_word </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>word</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>encoded</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>word_ufp6_size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>ufp6_dict</em>[][BITS - 1], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>word_ufp6_size array eith the sizes of each char representation Time complexity: O (W * M) W = length of each word M = <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> size representation Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>- pointer to a given word </td></tr>
    <tr><td class="paramname">encode</td><td>- pointer to a array (can be a row from matrix) </td></tr>
    <tr><td class="paramname">word_ufp6_size</td><td>- pointer to an array of pre-computed word_ufp6_sizes </td></tr>
    <tr><td class="paramname">k</td><td>- index of matrix row </td></tr>
    <tr><td class="paramname">sizes_ufp6</td><td>- pointer to an array with pre-computed sizes_ufp6 </td></tr>
    <tr><td class="paramname">ufp6_dict</td><td>- pointer to a matrix (dictionary) with each ufp6 representation pre-computed </td></tr>
    <tr><td class="paramname">W</td><td>- word length</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>word_ufp6_size array eith the sizes of each char representation Time complexity: O (W * M) W = length of word M = <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> size representation Extra Space: O(1) </p>
<p>initialize to 0 the array with ufp6 size</p>
<p>Check if word is supported in ufp6 to encode</p>
<p>get index in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> Table</p>
<p>Store the size of ufp6 representation of each char encoded</p>
<p>Copy the ufp6 representation to the encoded array (row in matrix_ufp6)</p>

</div>
</div>
<a id="a1330d54bcd4ea316647d71670388d795" name="a1330d54bcd4ea316647d71670388d795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1330d54bcd4ea316647d71670388d795">&#9670;&#160;</a></span>exch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exch </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Exchange"></a>
items between arr[i] and arr[j]</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer to int array </td></tr>
    <tr><td class="paramname">i</td><td>- index of item to be swapped with item j </td></tr>
    <tr><td class="paramname">j</td><td>- index of item to be swapped with item i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63ac05bfffb294b6a73a1426e276b75" name="ae63ac05bfffb294b6a73a1426e276b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63ac05bfffb294b6a73a1426e276b75">&#9670;&#160;</a></span>exch_rows_from_both_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exch_rows_from_both_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Exchange"></a>
items between arr[i] and arr[j]</h4>
<p>and exchange sizes stored in arr_ufp6_size,(no realloc needed) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">i</td><td>- index of a row to swap </td></tr>
    <tr><td class="paramname">j</td><td>- index of a row to swap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fbd6f856771294de0d4979da04d627f" name="a6fbd6f856771294de0d4979da04d627f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbd6f856771294de0d4979da04d627f">&#9670;&#160;</a></span>exch_rows_matrix_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exch_rows_matrix_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Exchange"></a>
items between arr[i] and arr[j]</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">i</td><td>- index of a row to swap </td></tr>
    <tr><td class="paramname">j</td><td>- index of a row to swap </td></tr>
  </table>
  </dd>
</dl>
<p>point row i to j</p>
<p>point j to i stored in temp</p>

</div>
</div>
<a id="a3aaa0fe3dd45f8a8445613a4bccf15b8" name="a3aaa0fe3dd45f8a8445613a4bccf15b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aaa0fe3dd45f8a8445613a4bccf15b8">&#9670;&#160;</a></span>exch_rows_matrix_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void exch_rows_matrix_ufp6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>i</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Exchange"></a>
items between arr[i] and arr[j]</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">i</td><td>- index of a row to swap </td></tr>
    <tr><td class="paramname">j</td><td>- index of a row to swap </td></tr>
  </table>
  </dd>
</dl>
<p>point row i to j</p>
<p>point j to i stored in temp</p>
<p>Exchange in arr_ufp6_size</p>

</div>
</div>
<a id="ac068fd70ca26d3588ec24f10c75cdac5" name="ac068fd70ca26d3588ec24f10c75cdac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac068fd70ca26d3588ec24f10c75cdac5">&#9670;&#160;</a></span>find_word_in_set_and_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_word_in_set_and_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to find given word in set comparing each word in set with given word and after remove and shift all rows in both matrix and matrix_ufp6 Time Complexity: O(N) N = size of words in set //strcmp has a really low time complexity that's why it will have a little cost because <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> words have MAX 7 bits </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">word</td><td>- pointer to word</td></tr>
  </table>
  </dd>
</dl>
<p>Function to find all occurrences given word in set comparing each word with given word and remove all and shift all rows in both matrix and matrix_ufp6 Time Complexity: O(N) N = size of words in set //strcmp has a really low time complexity because <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> words have MAX 7 bits Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">word</td><td>- pointer to word </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47bcd1312c981361d828815983a2b5e3" name="a47bcd1312c981361d828815983a2b5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bcd1312c981361d828815983a2b5e3">&#9670;&#160;</a></span>find_word_with_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_word_with_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>array_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Find"></a>
median between arr[lo], arr[mid] and arr[hi]</h4>
<p>and the size of occurrences in first position of that array Time Complexity of O(M + N * M) M = length of longest pattern N = size of rows (words in set) Extra Space: O(MAX_UFP6 * BITS - 1 + P) MAX_UFP6 * BITS - 1 for DFA and P = array to store indexes of words with given pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">patterns</td><td>- pointer to an array of pointers to characters (array of strings with patterns) </td></tr>
    <tr><td class="paramname">array_index</td><td>- pointer to a pointer to an array to store indexes of words found with pattern </td></tr>
  </table>
  </dd>
</dl>
<p>Check If the current pattern is in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> notation, 0-9 a-z A-Z</p>
<p>Pre-process the pattern into dfa</p>
<p>Search for words with given pattern And return address to array with indexes of words found in set with pattern</p>
<p>If found pattern in set</p>

</div>
</div>
<a id="aa3a8628d8e64a7efc1587cc2db96ad16" name="aa3a8628d8e64a7efc1587cc2db96ad16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a8628d8e64a7efc1587cc2db96ad16">&#9670;&#160;</a></span>find_words_with_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_words_with_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>patterns</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find patterns in a given set using KMP Algorithm Time Complexity of O(P (M + N * M)) M = length of longest pattern N = size of rows (words in set) P = size of patterns to search for Extra Space: O(MAX_UFP6 * BITS - 1 + P) MAX_UFP6 * BITS - 1 for DFA and P = array to store indexes of words with given pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">patterns</td><td>- pointer to an array of pointers to characters (array of strings with patterns) </td></tr>
    <tr><td class="paramname">W</td><td>- size of patterns to search </td></tr>
    <tr><td class="paramname">fn</td><td>- file name </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean,if set to 1 write to a txt file words found with given pattern</td></tr>
  </table>
  </dd>
</dl>
<p>Find patterns in a given set using KMP Algorithm Time Complexity of O(P (M + N * M)) M = length of longest pattern N = size of rows (words in set) P = size of patterns to search for Extra Space: O(MAX_UFP6 * BITS - 1 + P) MAX_UFP6 * BITS - 1 for DFA and P = array to store indexes of words with given pattern </p>
<p>Array to store the indexes of the patterns found in set</p>
<p>For each pattern</p>
<p>If flag == 1 and if found patterns with pattern write patterns found and their respective ufp6 representation to a txt file</p>

</div>
</div>
<a id="a0e471a0a35b34bd4905003f9ea0cb919" name="a0e471a0a35b34bd4905003f9ea0cb919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e471a0a35b34bd4905003f9ea0cb919">&#9670;&#160;</a></span>findMedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int findMedian </td>
          <td>(</td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Find"></a>
median between arr[lo], arr[mid] and arr[hi]</h4>
<p>to improve qsort </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer to array with words size </td></tr>
    <tr><td class="paramname">lo</td><td>- lower bound = 0 </td></tr>
    <tr><td class="paramname">mid</td><td>- middle index of array </td></tr>
    <tr><td class="paramname">hi</td><td>- higher bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return index of median </dd></dl>

</div>
</div>
<a id="ac28b1955ef487fec8b1e7de5abc8a61d" name="ac28b1955ef487fec8b1e7de5abc8a61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28b1955ef487fec8b1e7de5abc8a61d">&#9670;&#160;</a></span>fperror()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fperror </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>- message to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8118fa3cb7085214c19b2de21e83642f" name="a8118fa3cb7085214c19b2de21e83642f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8118fa3cb7085214c19b2de21e83642f">&#9670;&#160;</a></span>free_hash_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_hash_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_f_p6.html">UFP6</a> **</td>          <td class="paramname"><span class="paramname"><em>hash_table</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free the linked list in each bucket</p>
<p>Set the bucket to NULL after freeing the linked list</p>

</div>
</div>
<a id="a302db3993a889fcea336cf60ae2e5469" name="a302db3993a889fcea336cf60ae2e5469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302db3993a889fcea336cf60ae2e5469">&#9670;&#160;</a></span>freemem_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freemem_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Free"></a>
memory allocated in set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>
<p>Free each row from matrix of words and ufp6</p>
<p>Free pointer to matrix</p>
<p>Free pointer to matrix_ufp6</p>
<p>Free pointer to array with words size</p>
<p>Free pointer to array with ufp6 size</p>

</div>
</div>
<a id="aaebe7cf56667e0677705a189555c02b5" name="aaebe7cf56667e0677705a189555c02b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebe7cf56667e0677705a189555c02b5">&#9670;&#160;</a></span>gen_rnd_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char gen_rnd_char </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="generate"></a>
random char from</h4>
<p>'0' to '9' , 'a' to 'z' and 'A' to 'Z' </p><dl class="section return"><dt>Returns</dt><dd>generated char </dd></dl>
<p>Generate random size between 0 and MAX_UFP6</p>
<p>'0' to '9' (digits)</p>
<p>'a' to 'z' (lowercase letters)</p>
<p>'a' + (random_number - 10 ) because in ASCII table 'a' = 97 dec but in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> 'a' = 10 so for example if random size = 10 we need to get char 'a' so subtract 10 because from '0' to '9' it has digits and need to get the ASCII code from 'a' starting in '0' and sum the first char ('a') for example: 'a' + 10 - 10 = 'a'</p>
<p>'A' to 'Z' (uppercase letters)</p>
<p>In here subtract 36 because '0' to 'z' = 36 and the random size will be from 36 to RADIX and to get ASCII from 'A' to 'Z' start from '0' and sum 'A'</p>

</div>
</div>
<a id="a0e2ea41700a6f804f3c6837293ffe697" name="a0e2ea41700a6f804f3c6837293ffe697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2ea41700a6f804f3c6837293ffe697">&#9670;&#160;</a></span>generate_permutations_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generate_permutations_ufp6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *</td>          <td class="paramname"><span class="paramname"><em>hash_table</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>a</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>l</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>r</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Generate"></a>
random word size to store in arr_word_size</h4>
<p>into hash table to check if a permutation from a set was already generated from another set if repeated from set 1 set value of repeated to 1 , if repeated in both sets , set value to an odd number greater than 1, if only appear in set2 set to a even number Time Complexity: O(n!) n! = size of permutations Extra Space O(N + H) H = hash table N = length of string a </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>- pointer to <a class="el" href="struct_h_a_s_h_t_a_b_l_e.html" title="Struct to hold Hash table.">HASHTABLE</a> struct </td></tr>
    <tr><td class="paramname">a</td><td>- pointer to array containing string with <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation </td></tr>
    <tr><td class="paramname">l</td><td>- start index </td></tr>
    <tr><td class="paramname">r</td><td>- end index </td></tr>
    <tr><td class="paramname">flag</td><td>- to check is generating for set 1 or 2 </td></tr>
  </table>
  </dd>
</dl>
<p>Convert to int to eliminate leading zero's</p>
<p>Calculate size of string without leading 0's</p>
<p>Insert into hash table if val never added</p>
<p>Handle equal combinations based on the flag</p>
<p>change repeated variable if flag == 2 by +=2 To after check if combination appeared in both sets If so the val of repeated should be an odd value &gt; than 1</p>
<p>If only repeated on set1 the val of repeated should stay 1</p>
<p>Generate combinations only with desired size</p>
<p>Backtrack (swap back elements l and i)</p>

</div>
</div>
<a id="a823382a2c216d33a2634cd902ce1a636" name="a823382a2c216d33a2634cd902ce1a636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823382a2c216d33a2634cd902ce1a636">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int hash </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ufp6_encode</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Generate"></a>
random word size to store in arr_word_size</h4>
<p>This function iterates over each byte of the input data (ufp6_encode). For each byte: hash is updated by adding the current byte value. hash is left-shifted by 10 bits. The result is XORed with the right-shifted value of hash by 6 bits. After processing each byte, additional mixing is performed: hash is left-shifted by 3 bits. hash is XORed with the right-shifted value of hash by 11 bits. hash is left-shifted by 15 bits. Time Complexity : O(S) S = string length </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ufp6_encode</td><td>- pointer to string containing the <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation </td></tr>
    <tr><td class="paramname">size</td><td>- size of hash table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash value </dd></dl>
<p>hash left-shift 10 bits</p>
<p>XORed with the right-shifted value of hash by 6 bits</p>
<p>hash left-shift 3 bits</p>
<p>XORed with the right-shifted value of hash by 11 bits</p>
<p>hash left-shift 15 bits</p>
<p>Reduce to modulo of TABLE_SIZE</p>

</div>
</div>
<a id="a60a336db3b6b692d215cd3631fd86e48" name="a60a336db3b6b692d215cd3631fd86e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a336db3b6b692d215cd3631fd86e48">&#9670;&#160;</a></span>hash_table_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hash_table_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *</td>          <td class="paramname"><span class="paramname"><em>hash_table</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_u_f_p6.html">UFP6</a> *</td>          <td class="paramname"><span class="paramname"><em>new</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<p>Time Complexity: O(1) S </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>- pointer to struct <a class="el" href="struct_h_a_s_h_t_a_b_l_e.html" title="Struct to hold Hash table.">HASHTABLE</a> </td></tr>
    <tr><td class="paramname">new</td><td>- pointer to new <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> node </td></tr>
  </table>
  </dd>
</dl>
<p>Get hash value</p>
<p>Point new node to prev node</p>
<p>Add to head</p>

</div>
</div>
<a id="a9aeb349ef801ce1d964a32667cce2cd0" name="a9aeb349ef801ce1d964a32667cce2cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aeb349ef801ce1d964a32667cce2cd0">&#9670;&#160;</a></span>hash_table_lookup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_u_f_p6.html">UFP6</a> * hash_table_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *</td>          <td class="paramname"><span class="paramname"><em>hash_table</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>ufp6</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>chech if value is in hash table </p>
<h4><a class="anchor" id="Lookup"></a>
for a given string in hash table</h4>
<p>Time Complexity: O(N) N = size of nodes in bucket Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>- pointer to <a class="el" href="struct_h_a_s_h_t_a_b_l_e.html" title="Struct to hold Hash table.">HASHTABLE</a> struct </td></tr>
    <tr><td class="paramname">ufp6</td><td>- pointer to string containing the <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to node containing the string </dd></dl>
<p>Pointer to head of LL</p>
<p>Traverse LL</p>

</div>
</div>
<a id="a26edb02e573505a164e1ea18d9931909" name="a26edb02e573505a164e1ea18d9931909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26edb02e573505a164e1ea18d9931909">&#9670;&#160;</a></span>init_arr_ufp6_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_arr_ufp6_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Allocate"></a>
memory for matrix to store words, given array with pre-generated sizes of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31931eb9ac464b81089df00fa9fb1232" name="a31931eb9ac464b81089df00fa9fb1232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31931eb9ac464b81089df00fa9fb1232">&#9670;&#160;</a></span>init_arr_word_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_arr_word_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Allocate"></a>
memory for matrix to store words, given array with pre-generated sizes of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a501783d4e0fcd599169d15cbf6f60494" name="a501783d4e0fcd599169d15cbf6f60494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501783d4e0fcd599169d15cbf6f60494">&#9670;&#160;</a></span>init_hash_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_hash_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> **</td>          <td class="paramname"><span class="paramname"><em>hash_table</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize hash table pointers to NULL. </p>
<h4><a class="anchor" id="Initialize"></a>
SETS struct</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>- pointer to pointer to <a class="el" href="struct_h_a_s_h_t_a_b_l_e.html" title="Struct to hold Hash table.">HASHTABLE</a> struct </td></tr>
    <tr><td class="paramname">size</td><td>- size of hash table </td></tr>
    <tr><td class="paramname">count</td><td>- size of elements in Hash table </td></tr>
  </table>
  </dd>
</dl>
<p>Allocate mem for hash table (by init array of pointers to NULL)</p>

</div>
</div>
<a id="af43b71cc307a1637aae2aef3ed391239" name="af43b71cc307a1637aae2aef3ed391239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43b71cc307a1637aae2aef3ed391239">&#9670;&#160;</a></span>insert_new_UFP6_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_new_UFP6_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *</td>          <td class="paramname"><span class="paramname"><em>hash_table</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Create"></a>
and Insert node in Hash table</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>- pointer to string containing <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation </td></tr>
    <tr><td class="paramname">size</td><td>- size of string without leading 0's </td></tr>
  </table>
  </dd>
</dl>
<p>Allocate memory for ufp6_encode and copy str</p>

</div>
</div>
<a id="a260f22e58c106f02faa708e288c818d7" name="a260f22e58c106f02faa708e288c818d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260f22e58c106f02faa708e288c818d7">&#9670;&#160;</a></span>insert_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_ufp6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6_dict</em>[], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>ufp6_dict</em>[][BITS - 1], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>word</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3798ad42a105dc2af7d64086d4833635" name="a3798ad42a105dc2af7d64086d4833635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3798ad42a105dc2af7d64086d4833635">&#9670;&#160;</a></span>insert_word_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_word_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>word</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a110db8dd6cf62040e412364f2ab739d7" name="a110db8dd6cf62040e412364f2ab739d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110db8dd6cf62040e412364f2ab739d7">&#9670;&#160;</a></span>insert_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>words</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6_dict</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>ufp6_dict</em>[][BITS - 1], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<p>this function reallocates the memory for both arrays holding the sizes of words and their ufp6 representation , calculates the new words size and ufp6 and after reallocates also both matrix (matrix of words and matrix upf6) and then insert to the respective matrix. Time Complexity: O(N * W * M) N = size of words supported to insert W = length of word M = <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> size representation Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to set that contains both matrix , both arrays with sizes and the size of words </td></tr>
    <tr><td class="paramname">words</td><td>- array of words to be inserted </td></tr>
    <tr><td class="paramname">sizes_ufp6_dict</td><td>- array with precomputed sizes of each ufp6 representation </td></tr>
    <tr><td class="paramname">ufp6_dict</td><td>- precomputed dictionary with each ufp6 representation </td></tr>
    <tr><td class="paramname">num_words</td><td>- size of words to be inserted </td></tr>
  </table>
  </dd>
</dl>
<p>Store size of words supported</p>
<p>Check if words to be inserted are supported in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>
<p>Realloc memory for arr_word_size and arr_ufp6_size Time complexity: O(N) N = size of rows in set</p>
<p>Realloc mem for both matrix Time complexity: O(1)</p>
<p>If Word Supported insert into set</p>
<p>Store word size and ufp6 size calculated ,of new word to be inserted</p>
<p>If already allocated memory for both matrix , realloc to correct size of columns</p>
<p>Insert word into both matrix</p>

</div>
</div>
<a id="a2ad2da8aa7f668f406b118d171c2ab33" name="a2ad2da8aa7f668f406b118d171c2ab33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad2da8aa7f668f406b118d171c2ab33">&#9670;&#160;</a></span>insertion_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertion_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>Time Complexity: O(N^2) N = size of words Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">lo</td><td>- lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>- higher bound </td></tr>
    <tr><td class="paramname">d</td><td>- start at dth character </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 sort in ASC order , if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0778c149f5b7fe28e3fb9228a2ea5ef7" name="a0778c149f5b7fe28e3fb9228a2ea5ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0778c149f5b7fe28e3fb9228a2ea5ef7">&#9670;&#160;</a></span>insertion_sort_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insertion_sort_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>Time Complexity: O(N^2) N = size of words Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">lo</td><td>- lower bound </td></tr>
    <tr><td class="paramname">hi</td><td>- higher bound </td></tr>
    <tr><td class="paramname">d</td><td>- start at dth character </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 sort in ASC order , if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a2798f10e7e1b18c4e19cd5f71f220c" name="a7a2798f10e7e1b18c4e19cd5f71f220c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2798f10e7e1b18c4e19cd5f71f220c">&#9670;&#160;</a></span>is_sorted_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void is_sorted_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>by alphabetical order </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">N</td><td>- size of rows </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 check if sorted ASC, if set to 0 check if DESC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab4a064e55c0a607c89f4ae31a75f0c" name="a9ab4a064e55c0a607c89f4ae31a75f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab4a064e55c0a607c89f4ae31a75f0c">&#9670;&#160;</a></span>is_sorted_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void is_sorted_sizes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>by words size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">N</td><td>- size of rows </td></tr>
    <tr><td class="paramname">flag</td><td>-boolean, if set to 1 check if sorted ASC, if set to 0 check if DESC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf01e02d804416c09fa3e7c15698d8d9" name="acf01e02d804416c09fa3e7c15698d8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf01e02d804416c09fa3e7c15698d8d9">&#9670;&#160;</a></span>is_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_ufp6 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>word</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Check"></a>
if word is supported in UFP6</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>-pointer to word to be checked </td></tr>
    <tr><td class="paramname">W</td><td>- length of word to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return 1 if word is supported or return 0 if word is not supported </dd></dl>

</div>
</div>
<a id="ae848a36a8bac106333cbaec3fd1a3af3" name="ae848a36a8bac106333cbaec3fd1a3af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae848a36a8bac106333cbaec3fd1a3af3">&#9670;&#160;</a></span>KMP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KMP </td>
          <td>(</td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>pattern</em>[BITS - 1], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dfa</em>[MAX_UFP6][BITS - 1]</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="KMP"></a>
Algorithm to build DFA of a patter (word)</h4>
<p>Time Complexity: O(M) M = length of pattern Extra Space: O(MAX_UFP6 * BITS - 1) MAX_UFP6 * BITS - 1 for DFA </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>-pointer to pattern (word) to be found </td></tr>
    <tr><td class="paramname">dfa</td><td>-pointer to Deterministic Finite State Automaton (abstract string-searching machine)</td></tr>
  </table>
  </dd>
</dl>
<p>Function to build a DFA from a given pattern </p>
<p>Initialize DFA to 0</p>
<p>Until pattern_size</p>
<p>Calculate index of char in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> ASCII table in ASC order</p>
<p>Initialize first col of given row to 1</p>
<p>Calculate index char in ufp6 ASCII table in ASC order</p>
<p>copy mismatch cases</p>
<p>set match case</p>
<p>update restart state</p>

</div>
</div>
<a id="ab136cadda6cd8ca4f7610085182fe23d" name="ab136cadda6cd8ca4f7610085182fe23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab136cadda6cd8ca4f7610085182fe23d">&#9670;&#160;</a></span>knuth_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void knuth_shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>it shuffles the array generating random indexes and swap elements between those index , for better performance in qsort algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>
<p>Generate random index</p>
<p>Exchange rows and indexes from both matrix and arrays holding the sizes in <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct</p>

</div>
</div>
<a id="a893c09ccffd2b29d0b2d4bfa3a15d1c6" name="a893c09ccffd2b29d0b2d4bfa3a15d1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893c09ccffd2b29d0b2d4bfa3a15d1c6">&#9670;&#160;</a></span>less()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int less </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str1</td><td>- pointer to string1 </td></tr>
    <tr><td class="paramname">str2</td><td>- pointer to string2 </td></tr>
    <tr><td class="paramname">d</td><td>- start at dth character </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 compare to ASC order , if set to 0 compare to DESC order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if str1 &lt; str2 returns a non-zero size, if str1 &gt; str2 it returns 0 </dd></dl>

</div>
</div>
<a id="a3aa1e8d78680fb71f3c461f7dff33d67" name="a3aa1e8d78680fb71f3c461f7dff33d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa1e8d78680fb71f3c461f7dff33d67">&#9670;&#160;</a></span>matrix_encode_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_encode_realloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocate"></a>
memory for an int array of pointers (rows) and for each pointer (cols), initialize at 0</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct which contains array to reallocate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a775cb511b6aa690291a4c915d671e633" name="a775cb511b6aa690291a4c915d671e633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775cb511b6aa690291a4c915d671e633">&#9670;&#160;</a></span>matrix_init_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_init_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Allocate"></a>
memory for matrix to store words, given array with pre-generated sizes of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>
<p>Allocate memory for array of pointers</p>
<p>Allocate memory for each pointer to arrays (cols) // + 1 for '\0'</p>

</div>
</div>
<a id="a543fffbd4a9930e508c8ae1a43ee9759" name="a543fffbd4a9930e508c8ae1a43ee9759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543fffbd4a9930e508c8ae1a43ee9759">&#9670;&#160;</a></span>matrix_rnd_word_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_rnd_word_gen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Initialize"></a>
SETS struct</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>
<p>seed to generate random numbers</p>
<p>generate random char to fill word</p>
<p>terminate each word with '\0'</p>

</div>
</div>
<a id="a9cb1b2bd89ee16b9b07c7913014d2b7a" name="a9cb1b2bd89ee16b9b07c7913014d2b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb1b2bd89ee16b9b07c7913014d2b7a">&#9670;&#160;</a></span>matrix_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * matrix_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Convert"></a>
char into UFP6 filling array in reverse order into Dictionary</h4>
<p>Time Complexity: O (R * BITS - 1) R = size of rows Bits - 1 : Max size of columns Extra Space: O(S) S = sum of all bits in matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to string containing all the <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representations concatenated </dd></dl>
<p>Calculate exact size to allocate for buffer</p>
<p>for '\0'</p>
<p>Use snprintf to concatenate numbers to the buffer</p>
<p>Check for snprintf errors or buffer overflow</p>

</div>
</div>
<a id="a09aa42b969c4795fd0f055b0631d34f1" name="a09aa42b969c4795fd0f055b0631d34f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09aa42b969c4795fd0f055b0631d34f1">&#9670;&#160;</a></span>matrix_ufp6_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix_ufp6_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6_char</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Initialize"></a>
SETS struct</h4>
<p>calculating the size of each representation to allocate exact size of columns </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">sizes_ufp6_char</td><td>- pointer to pre-computed array with the size of each <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation of each <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> char </td></tr>
  </table>
  </dd>
</dl>
<p>Allocate memory for array of pointers</p>
<p>Allocate memory for each pointer to arrays</p>
<p>Calculate each <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation to allocate exact size of columns</p>

</div>
</div>
<a id="ae07bf10286bd75f8ad3d26951df189a0" name="ae07bf10286bd75f8ad3d26951df189a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07bf10286bd75f8ad3d26951df189a0">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>aux_matrix</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>aux_matrix_ufp6</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mid</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Merge"></a>
function used in mergesort algorithm</h4>
<p>Time Complexity: O(N) Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">aux_matrix</td><td>- pointer to an array of char pointers (auxiliary matrix_words) </td></tr>
    <tr><td class="paramname">aux_matrix_ufp6</td><td>- pointer to an array of int pointers (auxiliary matrix_ufp6) </td></tr>
    <tr><td class="paramname">lo</td><td>- start index of array </td></tr>
    <tr><td class="paramname">mid</td><td>- middle index of array </td></tr>
    <tr><td class="paramname">hi</td><td>- end index of array </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 sort in ASC order , if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>
<p>Sort in ASC order</p>
<p>Sort in DESC order</p>

</div>
</div>
<a id="a53c6840cbc2b232c18831c8ff94be3ec" name="a53c6840cbc2b232c18831c8ff94be3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c6840cbc2b232c18831c8ff94be3ec">&#9670;&#160;</a></span>msdRadixSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msdRadixSort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>array_sizes_ufp6</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>msdRadixSort </p>
<h4><a class="anchor" id="Sort"></a>
both matrix and matrix_ufp6 in alphabetical order (ASC and DESC)</h4>
<p>using MSD algorithm Time complexity: O(2 W(N+R)) R = Radix, N size of strings, W max size of chars in single word Extra Space: O(2N + DR) 2N = both aux arrays of size N, R = count array with size R to store char cumulative frequencies and D is the size of function-call stack depth (length of longest prefix match) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to SET struct </td></tr>
    <tr><td class="paramname">lo</td><td>- lower bound of matrix </td></tr>
    <tr><td class="paramname">hi</td><td>- higher bound of matrix </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 sort in ASC order , if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>
<p>Temp array of char pointers</p>
<p>Temp array of int pointers</p>

</div>
</div>
<a id="a0cedd8eeb4742c5687b4eeb7ceed506a" name="a0cedd8eeb4742c5687b4eeb7ceed506a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cedd8eeb4742c5687b4eeb7ceed506a">&#9670;&#160;</a></span>msdRadixSort_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msdRadixSort_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>aux</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>aux_ufp6</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>array_sizes_ufp6</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="MSD"></a>
algorithm , partition array into R pieces according to first char</h4>
<p>(use Key_indexed countin) and after recursively sort all strings that start with each char . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to SET struct </td></tr>
    <tr><td class="paramname">aux</td><td>- char pointers array to store sorted strings </td></tr>
    <tr><td class="paramname">array_sizes_ufp6</td><td>- int pointers array to store sorted ufp6 and </td></tr>
    <tr><td class="paramname">lo</td><td>- lower bound of matrix </td></tr>
    <tr><td class="paramname">hi</td><td>- higher bound of matrix </td></tr>
    <tr><td class="paramname">d</td><td>- depth of </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 sort in ASC order , if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>
<p>For small arrays, use Insertion Sort because msd has too much overhead for small arrays</p>
<p>Store frequencies of each char</p>
<p>Add frequencies of each char to count array</p>
<p>calculate Index to insert into count</p>
<ul>
<li>2 for after store cumulative frequencies</li>
</ul>
<p>Update cumulative frequencies of each char</p>
<p>Insert words into aux array in the right order //</p>
<p>Get char from row i col d</p>
<p>find right index in RADIX</p>
<p>insert into aux to aux and aux_ufp6 pointers to rows in sorted positions</p>
<p>increment in count array to insert in next pos</p>
<p>Copy values from aux to arr</p>
<p>aux is the sorted array, so change *(set-&gt;matrix + i) to point to sorted row from aux</p>
<p>calculate size of ufp6 representation moved to ufp6_matrix and store into arr_sizes_ufp6</p>
<p>calculate size of word moved to matrix and store into arr_word_sizes</p>
<p>Calculate lower bound of a set of words</p>
<p>Calculate higher bound of a set of words</p>
<p>recursive call to sort sets between low and hi d + 1 to go to next column from left to right</p>

</div>
</div>
<a id="a94e7df9550bc0449a14451851a9855dc" name="a94e7df9550bc0449a14451851a9855dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e7df9550bc0449a14451851a9855dc">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>to partition the array in half , so when pivot is changed on his left are the numbers lower than him and at his left are the size greater than pivot so pivot is already sorted </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to set struct </td></tr>
    <tr><td class="paramname">arr</td><td>- pointer to array with words size </td></tr>
    <tr><td class="paramname">lo</td><td>- start pos of low = 0 </td></tr>
    <tr><td class="paramname">hi</td><td>- start pos of hi = size of rows - 1 </td></tr>
  </table>
  </dd>
</dl>
<p>Scan from left to right as long as (arr[++i] &lt; pivot) If flag set to 1 sort in asc order</p>
<p>Scan from right to left as long as (arr[&ndash;j] &gt; pivot)</p>
<p>Scan from left to right as long as (arr[++i] &gt; pivot) In desc order</p>
<p>Scan from right to left as long as (arr[&ndash;j] &lt; pivot)</p>
<p>If pointers cross switch j with pivot and return pivot index</p>
<p>Swap rows in both matrix</p>
<p>Swap with partitioning item arr_size</p>

</div>
</div>
<a id="ada2596fe0f67cdebbd782f6bca8d8707" name="ada2596fe0f67cdebbd782f6bca8d8707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2596fe0f67cdebbd782f6bca8d8707">&#9670;&#160;</a></span>print_arr_word_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_arr_word_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cd323584c5100968802d3d5b9e449ef" name="a8cd323584c5100968802d3d5b9e449ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd323584c5100968802d3d5b9e449ef">&#9670;&#160;</a></span>print_combinations_found()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_combinations_found </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> *</td>          <td class="paramname"><span class="paramname"><em>hash_table</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only print if repeated flag is &gt; 1 and odd number</p>

</div>
</div>
<a id="a12f6add36c9ceff9594842c6aca6419e" name="a12f6add36c9ceff9594842c6aca6419e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f6add36c9ceff9594842c6aca6419e">&#9670;&#160;</a></span>print_found_words_and_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_found_words_and_ufp6 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>array_index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct that contains the array with all the words </td></tr>
    <tr><td class="paramname">array_index</td><td>- pointer to an array with found words indexes (rows indexes) in first pos of array store the size of words </td></tr>
  </table>
  </dd>
</dl>
<p>Starts in 1 because storing in index 0 the count of words found // if *array_index == 0 , no words found</p>

</div>
</div>
<a id="a607b9ff36242aa00e078ce5367080334" name="a607b9ff36242aa00e078ce5367080334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607b9ff36242aa00e078ce5367080334">&#9670;&#160;</a></span>print_kmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_kmp </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dfa</em>[MAX_UFP6][M_KMP]</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfa</td><td>- Deterministic finite state automaton (abstract string-searching machine) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abca37c925b0491d48070ed7d34ea7d16" name="abca37c925b0491d48070ed7d34ea7d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca37c925b0491d48070ed7d34ea7d16">&#9670;&#160;</a></span>print_matrix_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_matrix_char </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82f9da439fadfce30edfde1dc4ba9992" name="a82f9da439fadfce30edfde1dc4ba9992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f9da439fadfce30edfde1dc4ba9992">&#9670;&#160;</a></span>print_matrix_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_matrix_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Prints"></a>
the UFP6 codification in a set using iteration</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to set which contains both matrix , both arrays with sizes and the size of words </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69b15ac06834cc52f8b3ab90bd128513" name="a69b15ac06834cc52f8b3ab90bd128513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b15ac06834cc52f8b3ab90bd128513">&#9670;&#160;</a></span>print_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_f_p6.html">UFP6</a> **</td>          <td class="paramname"><span class="paramname"><em>hash_table</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>- pointer to array of pointers of type <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> (hash table) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac787f7c2907123f7a3a9b4026225a342" name="ac787f7c2907123f7a3a9b4026225a342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac787f7c2907123f7a3a9b4026225a342">&#9670;&#160;</a></span>print_ufp6_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_ufp6_dictionary </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bin_dict</em>[][BITS - 1], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>size_ufp6</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Function"></a>
to calculate UFP6 representation of all words and store in</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ufp6_dict</td><td>- pointer to Matrix of ufp6 representations of each char </td></tr>
    <tr><td class="paramname">size_ufp6</td><td>- pointer to arr holding sizes of each char representation in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a614b865a44ccba94c91a247e564d3f3e" name="a614b865a44ccba94c91a247e564d3f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614b865a44ccba94c91a247e564d3f3e">&#9670;&#160;</a></span>q_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void q_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@paragraphThis Quick sort algorithm to sort both matrix and matrix_ufp6, it uses divide and conquer strategy like merge sort, we first shuffle the array using Knuth-Shuffle algorithm, after we find median between lo mid and hi and exch with lo, then we partition the array so that for pivot, entry a[pivot] is in place , no larger entry to the left of pivot and no smaller entry to the right of pivot and then sort each subarray recursively For tiny sub-arrays use insertion sort (CUTOFF = 10) , because qsort has too much overhead for tiny sub-arrays Time Complexity: worst O(1/2N^2) Extra Space: O(log(N)) Not stable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to set struct </td></tr>
    <tr><td class="paramname">arr</td><td>- pointer to array with words size </td></tr>
    <tr><td class="paramname">lo</td><td>- start pos of low = 0 </td></tr>
    <tr><td class="paramname">hi</td><td>- start pos of hi = size of rows - 1 </td></tr>
  </table>
  </dd>
</dl>
<p>Cutoff to small subarrays // CUTOFF = 10</p>
<p>Improvement median of 3</p>
<p>Exchange arr[lo] with arr[median]</p>
<p>Exchange matrix[lo] with matrix[median], arr_size[lo] with arr_size[median], matrix_ufp6[lo] with matrix_ufp6[lo] and matrix_ufp6_size[lo] with matrix_ufp6_size[median]</p>

</div>
</div>
<a id="ae3af03ebc5906c9a52d48745f2e0a5db" name="ae3af03ebc5906c9a52d48745f2e0a5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3af03ebc5906c9a52d48745f2e0a5db">&#9670;&#160;</a></span>read_words_from_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_words_from_txt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fn</td><td>- pointer to string containing file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbb63e36b244b737f8f6140ca04bb96e" name="afbb63e36b244b737f8f6140ca04bb96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb63e36b244b737f8f6140ca04bb96e">&#9670;&#160;</a></span>read_words_from_txt_to_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_words_from_txt_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<p>File format number_words = 5 6-e 2 D b A h 5-Z f z 0 h 7-6 U 2 z S m 0 2-U H 5-h 7 e Q q </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- pointer to file </td></tr>
  </table>
  </dd>
</dl>
<p>read rowsize from file</p>
<p>Initialize set</p>
<p>Read set of words</p>
<p>Initialize matrix <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>

</div>
</div>
<a id="a53ed21ac12ea5242ab349ee86f219745" name="a53ed21ac12ea5242ab349ee86f219745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ed21ac12ea5242ab349ee86f219745">&#9670;&#160;</a></span>realloc_arr_ufp6_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_arr_ufp6_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocates"></a>
memory for an array of ints that contains the size of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct where our array is located so we can realloc </td></tr>
  </table>
  </dd>
</dl>
<p>Realloc memory for arr_ufp6_size</p>

</div>
</div>
<a id="a559b2b2f6d280317ba8b42593ed42496" name="a559b2b2f6d280317ba8b42593ed42496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a559b2b2f6d280317ba8b42593ed42496">&#9670;&#160;</a></span>realloc_arr_words_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_arr_words_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocates"></a>
memory for an array of ints that contains the size of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct where our array is located so we can realloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e25de36ac5cdb54a677792e9eccccc9" name="a4e25de36ac5cdb54a677792e9eccccc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e25de36ac5cdb54a677792e9eccccc9">&#9670;&#160;</a></span>realloc_col_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_col_ufp6 </td>
          <td>(</td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>mat_row</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col_words_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocate"></a>
memory for an int array of pointers (rows) and for each pointer (cols), initialize at 0</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_row</td><td>- pointer to an row to realloc </td></tr>
    <tr><td class="paramname">col_words_size</td><td>- size of word, used to realloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29705aa52acf5a708e189bb56665cee7" name="a29705aa52acf5a708e189bb56665cee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29705aa52acf5a708e189bb56665cee7">&#9670;&#160;</a></span>realloc_col_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_col_word </td>
          <td>(</td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>mat_row</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col_words_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocates"></a>
memory for an array of ints that contains the size of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_row</td><td>- pointer to an row to realloc </td></tr>
    <tr><td class="paramname">col_words_size</td><td>- size of word, used to realloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47976eaf9c7739c630c11b2045cd6e5f" name="a47976eaf9c7739c630c11b2045cd6e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47976eaf9c7739c630c11b2045cd6e5f">&#9670;&#160;</a></span>realloc_row_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_row_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocate"></a>
memory for an int array of pointers (rows) and for each pointer (cols), initialize at 0</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">row</td><td>- index of current row to shift from next to current </td></tr>
  </table>
  </dd>
</dl>
<p>Realloc row size if current row has lesser size than the next row</p>

</div>
</div>
<a id="af7fc561bcd9ebec14151a55c9861e1ed" name="af7fc561bcd9ebec14151a55c9861e1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fc561bcd9ebec14151a55c9861e1ed">&#9670;&#160;</a></span>realloc_rows_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_rows_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocates"></a>
memory for an array of ints that contains the size of each word</h4>
<p>to have the correct amount of rows in the matrix to the new word(s) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct where our matrix is located so we can realloc its rows </td></tr>
    <tr><td class="paramname">num_words</td><td>- current amount of words, so we reallocate to the necessary amount of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a9a4ecbbf9465d2e04789b05fe3ee55" name="a1a9a4ecbbf9465d2e04789b05fe3ee55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9a4ecbbf9465d2e04789b05fe3ee55">&#9670;&#160;</a></span>realloc_rows_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_rows_ufp6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Reallocates"></a>
memory for an array of ints that contains the size of each word</h4>
<p>to have the correct amount of rows in the matrix to hold new word(s) codification(s) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct where our matrix is located so we can realloc it's rows </td></tr>
    <tr><td class="paramname">num_words</td><td>- current amount of words, so we reallocate to the necessary amount of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73fad50f639741bbad440dddfb3c992e" name="a73fad50f639741bbad440dddfb3c992e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fad50f639741bbad440dddfb3c992e">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_h_a_s_h_t_a_b_l_e.html">HASHTABLE</a> **</td>          <td class="paramname"><span class="paramname"><em>hash_table</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to rehash the elements from the old hash table to the new one. </p>
<h4><a class="anchor" id="Rehash"></a>
elements from Hash table</h4>
<p>Time Complexity: O (N) N = size of elements in hash table </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash_table</td><td>- pointer to array of pointers of type <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> (hash table) </td></tr>
    <tr><td class="paramname">size</td><td>- new size of hash table </td></tr>
  </table>
  </dd>
</dl>
<p>Iterate through old hash table</p>
<p>Reinsert each element into the new hash table</p>
<p>Copy string to new node</p>
<p>Point new node to next</p>
<p>Add to head</p>
<p>Update the pointer to the new hash table</p>

</div>
</div>
<a id="a7feb79ca6d753d9f80a5d0a5c27062fb" name="a7feb79ca6d753d9f80a5d0a5c27062fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7feb79ca6d753d9f80a5d0a5c27062fb">&#9670;&#160;</a></span>remove_UFP6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_UFP6 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to remove <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation of given word adjusting rows from matrix_ufp6 Time Complexity: O(N) N = size of words in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> matrix Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">index</td><td>- index of <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation to be removed </td></tr>
  </table>
  </dd>
</dl>
<p>Check if the next row exists</p>
<p>If current row size is lesser than the next row, reallocate memory</p>
<p>Copy from next row to current</p>

</div>
</div>
<a id="ae498d9c29c8a58e05dea42441315f4f5" name="ae498d9c29c8a58e05dea42441315f4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae498d9c29c8a58e05dea42441315f4f5">&#9670;&#160;</a></span>remove_word_from_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_word_from_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_remove</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Remove"></a>
word from set, given array with the indexes of the rows in both matrix, adjusting</h4>
<p>both matrix .When adjusting rows If prev word size is lesser than the next, reallocate that row </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">arr_index_words_found</td><td>- pointer to an array of index, pos 0 has the size of words (indexes) found</td></tr>
  </table>
  </dd>
</dl>
<p>Function to remove word and <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation of given word and adjust rows from both matrix in set Time Complexity: O(N) N = size of words in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> matrix Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">index</td><td>- index of word (row) to be removed </td></tr>
  </table>
  </dd>
</dl>
<p>adjust rows of matrix and matrix_ufp6 moving next row to previous</p>
<p>Reallocate mem for row size if current row has lesser size than the next row</p>
<p>Copy values from next to current</p>
<p>Remove <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation from matrix_ufp6 in set by shifting rows</p>
<p>adjust size of rows of both matrix after deleting</p>
<p>free row and clear stored size</p>

</div>
</div>
<a id="a14a7342ea8b1f0361d9335b2b51a5c18" name="a14a7342ea8b1f0361d9335b2b51a5c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a7342ea8b1f0361d9335b2b51a5c18">&#9670;&#160;</a></span>remove_Words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_Words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>words</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function remove given Words and <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation from set Time Complexity: O(W * N) N = size of words in set W = size of words to remove Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">words</td><td>- pointer to an array of strings (words to be removed) </td></tr>
    <tr><td class="paramname">W</td><td>- size of words to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e0c8623bd8287e75f13fabc4b7ee657" name="a8e0c8623bd8287e75f13fabc4b7ee657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0c8623bd8287e75f13fabc4b7ee657">&#9670;&#160;</a></span>rnd_word_size_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rnd_word_size_gen </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Generate"></a>
random word size to store in arr_word_size</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer to array that stores the size of each word </td></tr>
    <tr><td class="paramname">W</td><td>- size of words to generate sizes </td></tr>
  </table>
  </dd>
</dl>
<p>seed to generate random numbers *&zwj;/</p>
<p>Generate numbers from 1 to BITS - 1 // sum + 1 to the result so never generates 0 *&zwj;/ And store in word_length *&zwj;/</p>

</div>
</div>
<a id="a61afcd9bd1d43eb70bc58a14f93fc8e9" name="a61afcd9bd1d43eb70bc58a14f93fc8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61afcd9bd1d43eb70bc58a14f93fc8e9">&#9670;&#160;</a></span>search_KMP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * search_KMP </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dfa</em>[MAX_UFP6][BITS - 1], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pattern_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Function"></a>
to calculate UFP6 representation of all words and store in</h4>
<p>Time complexity: O(N * M) N = total size of words in set M = length of pattern N = size of words in set Extra Space: O(P) P = size of array to store indexes of words with pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">dfa</td><td>- Deterministic finite state automaton (abstract string-searching machine) </td></tr>
    <tr><td class="paramname">pattern_length</td><td>- size of word to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns an array with indexes of words found in matrix containing the pattern, in the first pos of array it's stored the size of words (indexes) found</dd></dl>
<p>Function to search for a given word given size and pre-computed DFA </p>
<p>Start pos of arr_index where we want to insert all index that contains the given word Start to 1 to store in pos 0 the count of indexes</p>
<p>Calculate index char in ufp6 ASCII table in ASC order</p>
<p>Go through DFA</p>
<p>no backup</p>
<p>If found word in a row (if j gets to last state in DFA) store index in arr_index</p>
<p>Store in pos 0 of array the count of words found with pattern</p>
<p>if found words return pointer to array</p>

</div>
</div>
<a id="a41e8dd180d70e127b409dbb543b5a8b8" name="a41e8dd180d70e127b409dbb543b5a8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e8dd180d70e127b409dbb543b5a8b8">&#9670;&#160;</a></span>seed_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void seed_random </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clock function to measure processor time and use as a seed </p>
<h4><a class="anchor" id="Function"></a>
to calculate UFP6 representation of all words and store in</h4>

</div>
</div>
<a id="a6f716ebc0f8778349c9fabb8de345d12" name="a6f716ebc0f8778349c9fabb8de345d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f716ebc0f8778349c9fabb8de345d12">&#9670;&#160;</a></span>sets_struct_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sets_struct_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>number_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Initialize"></a>
SETS struct</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">number_words</td><td>- size of words to hold in set </td></tr>
  </table>
  </dd>
</dl>
<p>Store size of words (rows) of both matrix in set</p>
<p>Initialize arrays to store words size and <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> words representation</p>
<p>Generate random words size and store in arr_word_size array in set</p>
<p>Initialize matrix to hold words given sizes generated and stored in arr_word_size</p>
<p>Generate words given sizes stored in arr_word_size and store in matrix</p>
<p>Initialize matrix_ufp6 calculating size of each ufp6 representation of words to allocate for each pointer to row</p>

</div>
</div>
<a id="a26594aedef0cae2d575940358861c1c0" name="a26594aedef0cae2d575940358861c1c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26594aedef0cae2d575940358861c1c0">&#9670;&#160;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>aux_matrix</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>aux_matrix_ufp6</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Mergesort"></a>
recursive function , using "divide and conquer" strategy</h4>
<p>With 2 improvements implemented : Cutoff to small subarrays (CUTOFF = 10) and stop if already sorted Time Complexity: O(NlogN) Extra Space: O(2N) M = size of words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">aux_matrix</td><td>- pointer to an array of char pointers (auxiliary matrix_words) </td></tr>
    <tr><td class="paramname">aux_matrix_ufp6</td><td>- pointer to an array of int pointers (auxiliary matrix_ufp6) </td></tr>
    <tr><td class="paramname">lo</td><td>- start index of array </td></tr>
    <tr><td class="paramname">hi</td><td>- end index of array </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 sort in ASC order , if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>
<p>Cutoff to insertion sort for small sub-arrays CUTOFF = 10</p>
<p>Stop if already sorted</p>

</div>
</div>
<a id="a6d756a5798bf2b718ea13ff39576ca32" name="a6d756a5798bf2b718ea13ff39576ca32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d756a5798bf2b718ea13ff39576ca32">&#9670;&#160;</a></span>sort_by_alphabetical_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sort_by_alphabetical_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>sizes_ufp6</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Sort"></a>
both matrix and matrix_ufp6 in alphabetical order (ASC and DESC)</h4>
<p>using mergesort algorithm Time Complexity: O(NlogN) Extra Space: O(2M) M = size of words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">sizes_ufp6</td><td>- pointer to array with pre-computed sizes of <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> of each char </td></tr>
    <tr><td class="paramname">flag</td><td>- boolean, if set to 1 sort in ASC order , if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>
<p>Allocate memory for auxiliary arrays of pointers to use in mergesort algorithm</p>
<p>After sort calculate sizes of words and <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> from set of words and store in both arrays in struct, instead of exchanging inside sort algorithm, to have less extra space This function has a time complexity of O(N) so it won't change much about mergesort Time Complexity</p>

</div>
</div>
<a id="a40aec849b74f8bf7ff34034b534e171a" name="a40aec849b74f8bf7ff34034b534e171a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40aec849b74f8bf7ff34034b534e171a">&#9670;&#160;</a></span>sort_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sort_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Sort"></a>
both matrix and matrix_ufp6 in alphabetical order (ASC and DESC)</h4>
<p>using quicksort algorithm </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to set struct </td></tr>
    <tr><td class="paramname">flag</td><td>-boolean, if set to 1 sort in ASC order, if set to 0 sort in DESC order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2ecf5fb92d7dc3e3191d1c9a561a457" name="ae2ecf5fb92d7dc3e3191d1c9a561a457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ecf5fb92d7dc3e3191d1c9a561a457">&#9670;&#160;</a></span>swapc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swapc </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>x</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e49216f9942802fbec2e6744d402139" name="a6e49216f9942802fbec2e6744d402139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e49216f9942802fbec2e6744d402139">&#9670;&#160;</a></span>ufp6_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ufp6_dictionary </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ufp6_dict</em>[][BITS - 1], </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>size_ufp6</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Function"></a>
to calculate UFP6 representation of all words and store in</h4>
<p>each char </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ufp6_dict</td><td>- pointer to Matrix to store <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representations of each char </td></tr>
    <tr><td class="paramname">size_ufp6</td><td>- pointer to int array to store size of each <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation representation sizes of each char </td></tr>
  </table>
  </dd>
</dl>
<p>Convert '0' to '9' to <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>
<p>Calculate size of each <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation based on binary Edge cases when '0' because log2(0) = undefined but we need one bit to represent '0'</p>
<p>We know the size of bits to represent a given value by doing log2((digit)) + 1</p>
<p>Convert each char to ufp6</p>
<p>Convert 'a' to 'z' to <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>
<p>Convert 'A' to 'Z' to <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>

</div>
</div>
<a id="a215f3c8abe9fe5b82585ea4d53ae70d8" name="a215f3c8abe9fe5b82585ea4d53ae70d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215f3c8abe9fe5b82585ea4d53ae70d8">&#9670;&#160;</a></span>write_to_txt_benchmark_sorting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_to_txt_benchmark_sorting </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>time_delta_merge_s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>time_delta_msd</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>number_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>Time Complexity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">words</td><td>- pointer to array holding sizes of <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> of each char </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
