<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>projeto_lp1_aed1: functions/functions_2.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">projeto_lp1_aed1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_35baea09d55bebfe17654fdf4bf061ce.html">functions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">functions_2.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;time.h&gt;</code><br />
<code>#include &quot;<a class="el" href="functions__1_8h_source.html">functions_1.h</a>&quot;</code><br />
</div>
<p><a href="functions__2_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html">WORDS_HOLDER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding 2 sets.  <a href="struct_w_o_r_d_s___h_o_l_d_e_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html">VAL_AD_WORDS_HOLDER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding last_update date and <a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html" title="Struct holding 2 sets.">WORDS_HOLDER</a> struct.  <a href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic array of <a class="el" href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Struct holding last_update date and WORDS_HOLDER struct.">VAL_AD_WORDS_HOLDER</a>.  <a href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node of <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a>.  <a href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linked List of <a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Node of LL_WORDS_HOLDER.">NODE_LL_WORDS_HOLDER</a>.  <a href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d2bf2bd32b3ae17744c58d42b9c8f86" id="r_a8d2bf2bd32b3ae17744c58d42b9c8f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d2bf2bd32b3ae17744c58d42b9c8f86">dynamic_array_init</a> (int size)</td></tr>
<tr class="separator:a8d2bf2bd32b3ae17744c58d42b9c8f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f7df7c0121eecb76becd30a5fae9c0" id="r_a97f7df7c0121eecb76becd30a5fae9c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97f7df7c0121eecb76becd30a5fae9c0">dynamic_array_realloc</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *arr)</td></tr>
<tr class="separator:a97f7df7c0121eecb76becd30a5fae9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924b6d1c00255ce25ab589cf606b350d" id="r_a924b6d1c00255ce25ab589cf606b350d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a924b6d1c00255ce25ab589cf606b350d">print_AD</a> (const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *ad)</td></tr>
<tr class="separator:a924b6d1c00255ce25ab589cf606b350d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fd120d3c85ac8b3a167268cb243794" id="r_a48fd120d3c85ac8b3a167268cb243794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48fd120d3c85ac8b3a167268cb243794">insert_element_to_AD_in_order</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *ad_holder, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *s1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *s2, const char *last_date)</td></tr>
<tr class="separator:a48fd120d3c85ac8b3a167268cb243794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4594e078b38fc000a4655a5460c3b7a1" id="r_a4594e078b38fc000a4655a5460c3b7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4594e078b38fc000a4655a5460c3b7a1">print_words_found</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *arr, int *index_set1, int *index_set2, int index_ad)</td></tr>
<tr class="separator:a4594e078b38fc000a4655a5460c3b7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad420b5fa51d69b63d828464f002a810a" id="r_ad420b5fa51d69b63d828464f002a810a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad420b5fa51d69b63d828464f002a810a">insert_element_to_index_AD</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *ad_holder, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set2, const char *last_date, int index)</td></tr>
<tr class="separator:ad420b5fa51d69b63d828464f002a810a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01ad5335bc5c01732700762e5471188" id="r_af01ad5335bc5c01732700762e5471188"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af01ad5335bc5c01732700762e5471188">find_words_ad</a> (const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *arr, const char **words, int W, int start_index, int end_index, const char *fn, bool flag)</td></tr>
<tr class="separator:af01ad5335bc5c01732700762e5471188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae35b56f2ce3abd503218a14de8a2e6" id="r_a5ae35b56f2ce3abd503218a14de8a2e6"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ae35b56f2ce3abd503218a14de8a2e6">search_word</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const char *word)</td></tr>
<tr class="separator:a5ae35b56f2ce3abd503218a14de8a2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5e1c549ad8937313509a2f0fb928ad" id="r_adf5e1c549ad8937313509a2f0fb928ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf5e1c549ad8937313509a2f0fb928ad">is_valid_date</a> (const char *date_str)</td></tr>
<tr class="separator:adf5e1c549ad8937313509a2f0fb928ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa2f227391b79ff68927556158f649e" id="r_a5aa2f227391b79ff68927556158f649e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aa2f227391b79ff68927556158f649e">insert_to_VAL_AD_WORDS_HOLDER</a> (<a class="el" href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html">VAL_AD_WORDS_HOLDER</a> *val_ad_words_holder, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set2, const char *last_date)</td></tr>
<tr class="separator:a5aa2f227391b79ff68927556158f649e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcac208c915bad7778b99646abee175" id="r_a4fcac208c915bad7778b99646abee175"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fcac208c915bad7778b99646abee175">get_current_date</a> ()</td></tr>
<tr class="separator:a4fcac208c915bad7778b99646abee175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225987073ba24cf20f649041938c6edb" id="r_a225987073ba24cf20f649041938c6edb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a225987073ba24cf20f649041938c6edb">bin_search_insert_pos</a> (const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *arr_din, const char *date)</td></tr>
<tr class="separator:a225987073ba24cf20f649041938c6edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f4720088b3f7fd28496a190caa4bff" id="r_aa0f4720088b3f7fd28496a190caa4bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0f4720088b3f7fd28496a190caa4bff">delete_element_index</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *ad, int index)</td></tr>
<tr class="separator:aa0f4720088b3f7fd28496a190caa4bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3732fee5827012efb0e5c622364e1c29" id="r_a3732fee5827012efb0e5c622364e1c29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3732fee5827012efb0e5c622364e1c29">realloc_AD</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *ad_holder, int size)</td></tr>
<tr class="memdesc:a3732fee5827012efb0e5c622364e1c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double the size when array is full while inserting in ad, halve the size when array is one-quarterfull while removing element from ad.  <br /></td></tr>
<tr class="separator:a3732fee5827012efb0e5c622364e1c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940a1a1cb8453c8dbf27d93266d56b46" id="r_a940a1a1cb8453c8dbf27d93266d56b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a940a1a1cb8453c8dbf27d93266d56b46">free_dynamic_array</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *arr)</td></tr>
<tr class="separator:a940a1a1cb8453c8dbf27d93266d56b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78c10e000115e85f60876f2af4b4e15" id="r_aa78c10e000115e85f60876f2af4b4e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa78c10e000115e85f60876f2af4b4e15">ll_init</a> ()</td></tr>
<tr class="separator:aa78c10e000115e85f60876f2af4b4e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e50bafd91246aac8d9f5d32351d29fc" id="r_a2e50bafd91246aac8d9f5d32351d29fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e50bafd91246aac8d9f5d32351d29fc">free_ll_words_holder</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll)</td></tr>
<tr class="separator:a2e50bafd91246aac8d9f5d32351d29fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a6e71b0ffbd37de7ff8fd7efa180c0" id="r_a86a6e71b0ffbd37de7ff8fd7efa180c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86a6e71b0ffbd37de7ff8fd7efa180c0">create_words_holder_node</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set2, const char *last_date)</td></tr>
<tr class="separator:a86a6e71b0ffbd37de7ff8fd7efa180c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c48d28da0082808cf75bee2f67183e" id="r_a98c48d28da0082808cf75bee2f67183e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98c48d28da0082808cf75bee2f67183e">insert_node_ll_sorted</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set2, const char *last_date)</td></tr>
<tr class="separator:a98c48d28da0082808cf75bee2f67183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a3269522c2476a05cd9615866d91d0" id="r_a03a3269522c2476a05cd9615866d91d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a3269522c2476a05cd9615866d91d0">insert_node_ll_index</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set2, const char *last_date, int index)</td></tr>
<tr class="separator:a03a3269522c2476a05cd9615866d91d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a524383b327a0dcba8a84ee33395c3d" id="r_a7a524383b327a0dcba8a84ee33395c3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a524383b327a0dcba8a84ee33395c3d">print_ll_words_holder</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll)</td></tr>
<tr class="separator:a7a524383b327a0dcba8a84ee33395c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad755b423216e7d87aca5766efa3581f5" id="r_ad755b423216e7d87aca5766efa3581f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad755b423216e7d87aca5766efa3581f5">insert_to_ll_given_pointers_node</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set2, const char *last_date, <a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *curr, <a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *prev)</td></tr>
<tr class="separator:ad755b423216e7d87aca5766efa3581f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59138ddee0181eb1d460e72bb200edd3" id="r_a59138ddee0181eb1d460e72bb200edd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59138ddee0181eb1d460e72bb200edd3">find_mid_ll</a> (<a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *lo, <a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *hi)</td></tr>
<tr class="separator:a59138ddee0181eb1d460e72bb200edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad3c9f3f134fedd4513022a7203f92" id="r_a5fad3c9f3f134fedd4513022a7203f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fad3c9f3f134fedd4513022a7203f92">delete_ll_node_index</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, int index)</td></tr>
<tr class="separator:a5fad3c9f3f134fedd4513022a7203f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573246300a53245053b1eec971e2e0d3" id="r_a573246300a53245053b1eec971e2e0d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573246300a53245053b1eec971e2e0d3">find_word_ll</a> (const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, char **words, int W, int lo, int hi, const char *fn, bool flag)</td></tr>
<tr class="separator:a573246300a53245053b1eec971e2e0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7405bcceb22729077418a4e015d63b6" id="r_ac7405bcceb22729077418a4e015d63b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7405bcceb22729077418a4e015d63b6">find_words_ll</a> (const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const char **words, const char *fn, int W, int start_index_node, int end_index_node, bool flag)</td></tr>
<tr class="separator:ac7405bcceb22729077418a4e015d63b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cee816275b5da6ee477ada2db2c4b47" id="r_a7cee816275b5da6ee477ada2db2c4b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cee816275b5da6ee477ada2db2c4b47">print_words_found_ll</a> (<a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *ll, int *index_set1, int *index_set2, int j)</td></tr>
<tr class="separator:a7cee816275b5da6ee477ada2db2c4b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515b3102e44b80d9157e0ba3c64cfdab" id="r_a515b3102e44b80d9157e0ba3c64cfdab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515b3102e44b80d9157e0ba3c64cfdab">write_set_to_txt</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a515b3102e44b80d9157e0ba3c64cfdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a06ffe7e28a7e569955f95abd4fb0" id="r_a3c2a06ffe7e28a7e569955f95abd4fb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c2a06ffe7e28a7e569955f95abd4fb0">write_set_ufp6_to_txt</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a3c2a06ffe7e28a7e569955f95abd4fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088315e2ec8b05049380f37cd3754bb9" id="r_a088315e2ec8b05049380f37cd3754bb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a088315e2ec8b05049380f37cd3754bb9">save_set_txt</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, char *filename)</td></tr>
<tr class="separator:a088315e2ec8b05049380f37cd3754bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b51624ce0b6c67e56df1b3365b0f5ea" id="r_a5b51624ce0b6c67e56df1b3365b0f5ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b51624ce0b6c67e56df1b3365b0f5ea">save_both_sets_to_txt</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *s1, const <a class="el" href="struct_s_e_t_s.html">SETS</a> *s2, char *filename)</td></tr>
<tr class="separator:a5b51624ce0b6c67e56df1b3365b0f5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96cd9754599ef28606eb9a7ba3b9d12" id="r_ab96cd9754599ef28606eb9a7ba3b9d12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab96cd9754599ef28606eb9a7ba3b9d12">write_words_found_in_ll_to_txt</a> (const <a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *current, const int *index_set1, const int *index_set2, const char *filename, int index_ll)</td></tr>
<tr class="separator:ab96cd9754599ef28606eb9a7ba3b9d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47246c505c8e816fc6d569a973397935" id="r_a47246c505c8e816fc6d569a973397935"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47246c505c8e816fc6d569a973397935">write_words_found_in_da_to_txt</a> (const <a class="el" href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html">VAL_AD_WORDS_HOLDER</a> *val_ad, const int *index_set1, const int *index_set2, const char *filename, int index_ad)</td></tr>
<tr class="separator:a47246c505c8e816fc6d569a973397935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4caae196df0cb947b4d52622b8823803" id="r_a4caae196df0cb947b4d52622b8823803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4caae196df0cb947b4d52622b8823803">write_index_array_words_to_file</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp, const int *index_array)</td></tr>
<tr class="separator:a4caae196df0cb947b4d52622b8823803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3e7d3980db8cf1a7c76e10ca506982" id="r_a1c3e7d3980db8cf1a7c76e10ca506982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c3e7d3980db8cf1a7c76e10ca506982">write_index_array_ufp6_to_file</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp, const int *index_array, int r)</td></tr>
<tr class="separator:a1c3e7d3980db8cf1a7c76e10ca506982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c97b1938ca040f863091df7798ab4f2" id="r_a0c97b1938ca040f863091df7798ab4f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c97b1938ca040f863091df7798ab4f2">read_txt_to_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a0c97b1938ca040f863091df7798ab4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1837fce597c7d37e0997b0bb574e1d9b" id="r_a1837fce597c7d37e0997b0bb574e1d9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1837fce597c7d37e0997b0bb574e1d9b">read_txt_words</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a1837fce597c7d37e0997b0bb574e1d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667e6596e889c9b019e2907d867f1235" id="r_a667e6596e889c9b019e2907d867f1235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a667e6596e889c9b019e2907d867f1235">sets_struct_init_v2</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, int num_words)</td></tr>
<tr class="separator:a667e6596e889c9b019e2907d867f1235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665ad0afb315c507e44df494d97ae39f" id="r_a665ad0afb315c507e44df494d97ae39f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a665ad0afb315c507e44df494d97ae39f">calloc_col_word</a> (char **mat_row, int col_words_size)</td></tr>
<tr class="separator:a665ad0afb315c507e44df494d97ae39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcc269e025fa6703c431e57d8318e58" id="r_a4fcc269e025fa6703c431e57d8318e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fcc269e025fa6703c431e57d8318e58">free_index_arrays</a> (int *arr1, int *arr2)</td></tr>
<tr class="separator:a4fcc269e025fa6703c431e57d8318e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822934c79355300703352eebe6fb6212" id="r_a822934c79355300703352eebe6fb6212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a822934c79355300703352eebe6fb6212">calloc_col_ufp6</a> (int **mat_row, int col_words_size)</td></tr>
<tr class="separator:a822934c79355300703352eebe6fb6212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc6876e44f60aa05c0454310df5db94" id="r_acdc6876e44f60aa05c0454310df5db94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdc6876e44f60aa05c0454310df5db94">read_ufp6_file_to_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:acdc6876e44f60aa05c0454310df5db94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edc6611867bd1fc8e590887bbe5f95d" id="r_a0edc6611867bd1fc8e590887bbe5f95d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0edc6611867bd1fc8e590887bbe5f95d">write_ad_to_txt</a> (const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *ad, const char *fn)</td></tr>
<tr class="separator:a0edc6611867bd1fc8e590887bbe5f95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4d2fd78407125fb4f66884563ef62d" id="r_aed4d2fd78407125fb4f66884563ef62d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4d2fd78407125fb4f66884563ef62d">write_both_sets_to_txt</a> (const <a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html">WORDS_HOLDER</a> *wordsHolder, FILE *fp)</td></tr>
<tr class="separator:aed4d2fd78407125fb4f66884563ef62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac44da663698d772b30126ad06a41d86" id="r_aac44da663698d772b30126ad06a41d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac44da663698d772b30126ad06a41d86">read_from_txt_to_ad</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> **ad, const char *fn, bool flag)</td></tr>
<tr class="separator:aac44da663698d772b30126ad06a41d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b9cb10200cfc6a6d4bd10210dd03f6" id="r_a07b9cb10200cfc6a6d4bd10210dd03f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07b9cb10200cfc6a6d4bd10210dd03f6">write_ll_to_txt</a> (const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const char *fn)</td></tr>
<tr class="separator:a07b9cb10200cfc6a6d4bd10210dd03f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1973a6c5c78356d26936fd8a460a06" id="r_a8e1973a6c5c78356d26936fd8a460a06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e1973a6c5c78356d26936fd8a460a06">write_set_to_binfile</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a8e1973a6c5c78356d26936fd8a460a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a34511a531c457034f83c0b157d22d" id="r_af0a34511a531c457034f83c0b157d22d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0a34511a531c457034f83c0b157d22d">write_set_ufp6_to_binfile</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:af0a34511a531c457034f83c0b157d22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5623bed6440cc637ff0749904079a2d2" id="r_a5623bed6440cc637ff0749904079a2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5623bed6440cc637ff0749904079a2d2">write_both_sets_to_binfile</a> (const <a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html">WORDS_HOLDER</a> *wordsHolder, FILE *fp)</td></tr>
<tr class="memdesc:a5623bed6440cc637ff0749904079a2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write both Sets to bin file.  <br /></td></tr>
<tr class="separator:a5623bed6440cc637ff0749904079a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1493e5ee98877a7d6baefa2006b2f7ee" id="r_a1493e5ee98877a7d6baefa2006b2f7ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1493e5ee98877a7d6baefa2006b2f7ee">write_words_found_to_txt_set_with_pattern</a> (const <a class="el" href="struct_s_e_t_s.html">SETS</a> *set, const int *array_index_words_found_set, const char *filename, const char *pattern)</td></tr>
<tr class="separator:a1493e5ee98877a7d6baefa2006b2f7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5353eb78bf739efca75cf1e8aa84d81" id="r_ab5353eb78bf739efca75cf1e8aa84d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5353eb78bf739efca75cf1e8aa84d81">read_from_txt_to_ll</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const char *fn, bool flag)</td></tr>
<tr class="separator:ab5353eb78bf739efca75cf1e8aa84d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ccad969ddb8710274e2b0a33431aa9" id="r_a08ccad969ddb8710274e2b0a33431aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08ccad969ddb8710274e2b0a33431aa9">read_ufp6_binfile_to_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a08ccad969ddb8710274e2b0a33431aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea60e529a5df540b68b2531f8aea9c33" id="r_aea60e529a5df540b68b2531f8aea9c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea60e529a5df540b68b2531f8aea9c33">read_from_bin_to_ad</a> (<a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> **ad, const char *fn, bool flag)</td></tr>
<tr class="separator:aea60e529a5df540b68b2531f8aea9c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8624201ed5c310a5aaf37fbb67a654d0" id="r_a8624201ed5c310a5aaf37fbb67a654d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8624201ed5c310a5aaf37fbb67a654d0">write_ad_to_bin</a> (const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *ad, const char *fn)</td></tr>
<tr class="separator:a8624201ed5c310a5aaf37fbb67a654d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177155ce7ef862f4010f0b4143c5c3e" id="r_a7177155ce7ef862f4010f0b4143c5c3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7177155ce7ef862f4010f0b4143c5c3e">read_binfile_to_set</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a7177155ce7ef862f4010f0b4143c5c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4ea21ee52262e16f2feb81269232eb" id="r_a6c4ea21ee52262e16f2feb81269232eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c4ea21ee52262e16f2feb81269232eb">read_binfile_words</a> (<a class="el" href="struct_s_e_t_s.html">SETS</a> *set, FILE *fp)</td></tr>
<tr class="separator:a6c4ea21ee52262e16f2feb81269232eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75834cc1e4d38024c9940123c923acbb" id="r_a75834cc1e4d38024c9940123c923acbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75834cc1e4d38024c9940123c923acbb">write_ll_to_binfile</a> (const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const char *fn)</td></tr>
<tr class="separator:a75834cc1e4d38024c9940123c923acbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bbd8b79b8cfdbccbf580afe9b2dcf56" id="r_a6bbd8b79b8cfdbccbf580afe9b2dcf56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bbd8b79b8cfdbccbf580afe9b2dcf56">read_from_binfile_to_ll</a> (<a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *ll, const char *fn, bool flag)</td></tr>
<tr class="separator:a6bbd8b79b8cfdbccbf580afe9b2dcf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2850f9ea5edc9b80de7297df4192e402" id="r_a2850f9ea5edc9b80de7297df4192e402"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2850f9ea5edc9b80de7297df4192e402">main_functions_2</a> (int argc, char **argv)</td></tr>
<tr class="separator:a2850f9ea5edc9b80de7297df4192e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a225987073ba24cf20f649041938c6edb" name="a225987073ba24cf20f649041938c6edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225987073ba24cf20f649041938c6edb">&#9670;&#160;</a></span>bin_search_insert_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bin_search_insert_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>arr_din</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Function"></a>
to calculate UFP6 representation of all words and store in</h4>
<p>using binary search </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr_din</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">date</td><td>- new_date of the element we want to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lo - if found target it returns the position of target in dynamic array if target is not found returns the position where should be added example1: index 0 24-11-2023 index 1 26-11-2023 , new_date 25-11-2023 - returns 1 example2: index 0 24-11-2023 , new_date 23-11-2023 return 0 example3: index 0 24-11-2023 , new_date 25-11-2023 return 1</dd></dl>
<h4><a class="anchor" id="binary"></a>
search to search for the position in AD where</h4>
<p>new element will be inserted </p>
<h4><a class="anchor" id="binary_search"></a>
O(log(N)) , strcmp O(D), Time complexity O(Dlog(N)) , Extra Space O(1) (inplace)</h4>
<p>If elements are equal, insert at the current position</p>
<p>return insert position</p>

</div>
</div>
<a id="a822934c79355300703352eebe6fb6212" name="a822934c79355300703352eebe6fb6212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822934c79355300703352eebe6fb6212">&#9670;&#160;</a></span>calloc_col_ufp6()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calloc_col_ufp6 </td>
          <td>(</td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>mat_row</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col_words_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Allocate"></a>
memory for matrix to store words, given array with pre-generated sizes of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_row</td><td>- pointer to row from matrix <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> to allocate memory to store <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation </td></tr>
    <tr><td class="paramname">col_words_size</td><td>- size of columns to be allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a665ad0afb315c507e44df494d97ae39f" name="a665ad0afb315c507e44df494d97ae39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665ad0afb315c507e44df494d97ae39f">&#9670;&#160;</a></span>calloc_col_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calloc_col_word </td>
          <td>(</td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>mat_row</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>col_words_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Allocate"></a>
memory for matrix to store words, given array with pre-generated sizes of each word</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat_row</td><td>- pointer to row from matrix to allocate memory to store word </td></tr>
    <tr><td class="paramname">col_words_size</td><td>- size of columns to be allocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86a6e71b0ffbd37de7ff8fd7efa180c0" name="a86a6e71b0ffbd37de7ff8fd7efa180c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a6e71b0ffbd37de7ff8fd7efa180c0">&#9670;&#160;</a></span>create_words_holder_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> * create_words_holder_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last_date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Create"></a>
and Insert node in Hash table</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set1</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">set2</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">last_date</td><td>- pointer to string containing the last update date </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to new node </dd></dl>
<p>Calloc to initialize to 0 or NULL vals in struct</p>
<p>Copy to node</p>

</div>
</div>
<a id="aa0f4720088b3f7fd28496a190caa4bff" name="aa0f4720088b3f7fd28496a190caa4bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f4720088b3f7fd28496a190caa4bff">&#9670;&#160;</a></span>delete_element_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_element_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ad</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Delete"></a>
element from Dynamic array by shifting the elements,</h4>
<p>if dynamic array is one-quarter full halve the size </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">index</td><td>- index of Dynamic Array to remove element </td></tr>
  </table>
  </dd>
</dl>
<p>Halve the size when array is one-quarter full</p>
<p>Shift elements from next to previous starting from index</p>
<p>Free Memory of last element</p>

</div>
</div>
<a id="a5fad3c9f3f134fedd4513022a7203f92" name="a5fad3c9f3f134fedd4513022a7203f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fad3c9f3f134fedd4513022a7203f92">&#9670;&#160;</a></span>delete_ll_node_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_ll_node_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Delete"></a>
element from Dynamic array by shifting the elements,</h4>
<p>Time Complexity: O(N - 1) N = size of nodes in LL Extra Space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to Linked List Words Holder </td></tr>
    <tr><td class="paramname">index</td><td>- index of node in Linked List to be deleted </td></tr>
  </table>
  </dd>
</dl>
<p>Traverse LL to find node at given index to be deleted</p>
<p>Use pointer to last node in <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> so don't need to traverse linked list when deleting last node</p>
<p>Remove between two nodes</p>
<p>Point previous node to the next node of node to be deleted</p>
<p>Point next node of node to be deleted to prev node pointed also by node to be deleted</p>
<p>Remove node in tail</p>
<p>Point tail to prev node</p>
<p>Point prev node to NULL</p>
<p>Remove node in head</p>
<p>Point head to next node</p>
<p>Point next node to NULL</p>

</div>
</div>
<a id="a8d2bf2bd32b3ae17744c58d42b9c8f86" name="a8d2bf2bd32b3ae17744c58d42b9c8f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2bf2bd32b3ae17744c58d42b9c8f86">&#9670;&#160;</a></span>dynamic_array_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> * dynamic_array_init </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Initialize"></a>
SETS struct</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>- size of dynamic array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> struct created </dd></dl>

</div>
</div>
<a id="a97f7df7c0121eecb76becd30a5fae9c0" name="a97f7df7c0121eecb76becd30a5fae9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f7df7c0121eecb76becd30a5fae9c0">&#9670;&#160;</a></span>dynamic_array_realloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dynamic_array_realloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Realloc"></a>
dynamic array</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer to struct dynamic array of words holder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59138ddee0181eb1d460e72bb200edd3" name="a59138ddee0181eb1d460e72bb200edd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59138ddee0181eb1d460e72bb200edd3">&#9670;&#160;</a></span>find_mid_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> * find_mid_ll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>hi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Find"></a>
median between arr[lo], arr[mid] and arr[hi]</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>- pointer to lower node </td></tr>
    <tr><td class="paramname">hi</td><td>- pointer to higher node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to middle node</dd></dl>
<p>Find midpoint of Linked List using fast_ptr and slow_ptr, fast_ptr advances two nodes at a time and slow_ptr advances one node at a time so divides the search space in half at each step O(N) </p>

</div>
</div>
<a id="a573246300a53245053b1eec971e2e0d3" name="a573246300a53245053b1eec971e2e0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573246300a53245053b1eec971e2e0d3">&#9670;&#160;</a></span>find_word_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_word_ll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>words</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lo</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>hi</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="search"></a>
words and their respective ufp6 at given node using KMP algorithm</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to Linked List Words Holder </td></tr>
    <tr><td class="paramname">words</td><td>- array of words to search in LL </td></tr>
    <tr><td class="paramname">W</td><td>- size of words array </td></tr>
    <tr><td class="paramname">lo</td><td>- start index node </td></tr>
    <tr><td class="paramname">hi</td><td>- end index node </td></tr>
    <tr><td class="paramname">fn</td><td>- file name </td></tr>
    <tr><td class="paramname">flag</td><td>- if set to 1 write output to a txt file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01ad5335bc5c01732700762e5471188" name="af01ad5335bc5c01732700762e5471188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01ad5335bc5c01732700762e5471188">&#9670;&#160;</a></span>find_words_ad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_words_ad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>words</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Find"></a>
median between arr[lo], arr[mid] and arr[hi]</h4>
<p>and write to a txt file the output Time Complexity: O(W * A * N + M) W = size of words to search for in dynamic array A = size of elements in da to search for words N = size of words in set1 , M = size of words in set2 Extra Space: O(N + M) N = size of words in set1 , M = size of words in set2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">words</td><td>- pointer to an array of pointers to strings containing the words to be found </td></tr>
    <tr><td class="paramname">W</td><td>- size of words to find </td></tr>
    <tr><td class="paramname">start_index</td><td>- first index of Dynamic array to search for each word </td></tr>
    <tr><td class="paramname">end_index</td><td>- last index of Dynamic array to search for each word </td></tr>
    <tr><td class="paramname">fn</td><td>- pointer to string containing filename </td></tr>
    <tr><td class="paramname">flag</td><td>- if set to 1 output to a txt file words found and their respective <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representations </td></tr>
  </table>
  </dd>
</dl>
<p>Calculate length of string</p>
<p>Check if word is valid in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>
<p>If flag set to 1 output found words and <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> to a txt file</p>

</div>
</div>
<a id="ac7405bcceb22729077418a4e015d63b6" name="ac7405bcceb22729077418a4e015d63b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7405bcceb22729077418a4e015d63b6">&#9670;&#160;</a></span>find_words_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void find_words_ll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>words</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>W</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>start_index_node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>end_index_node</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="search"></a>
words and their respective ufp6 at given node using KMP algorithm</h4>
<p>between given indexes of nodes Time Complexity: O(W * L * N + M) W = size of words to search for in dynamic array L = size of nodes in LL to search for words N = size of words in set1 M = size of words in set2 Extra Space: O(N + M) N = size of words in set1 , M = size of words in set2 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to Linked List Words Holder </td></tr>
    <tr><td class="paramname">words</td><td>- array of words to search in LL </td></tr>
    <tr><td class="paramname">W</td><td>- size of words array </td></tr>
    <tr><td class="paramname">start_index_node</td><td>- start index node </td></tr>
    <tr><td class="paramname">end_index_node</td><td>- end index node </td></tr>
    <tr><td class="paramname">fn</td><td>- file name </td></tr>
    <tr><td class="paramname">flag</td><td>- if set to 1 write output to a txt file </td></tr>
  </table>
  </dd>
</dl>
<p>Check if out of bounds</p>
<p>If only want to find in last node given words</p>
<p>Get pointer to starting node given index</p>
<p>Use pointer to last node in <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> so don't need to traverse linked list to get pointer to last node</p>
<p>Calculate length of string</p>
<p>Check if word is valid in <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a></p>
<p>Search for words in each set and store indexes in</p>
<p>If flag set to 1 output found words and <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> to a txt file</p>

</div>
</div>
<a id="a940a1a1cb8453c8dbf27d93266d56b46" name="a940a1a1cb8453c8dbf27d93266d56b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940a1a1cb8453c8dbf27d93266d56b46">&#9670;&#160;</a></span>free_dynamic_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_dynamic_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Free"></a>
memory allocated in set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
  </table>
  </dd>
</dl>
<p>free both sets of each index</p>

</div>
</div>
<a id="a4fcc269e025fa6703c431e57d8318e58" name="a4fcc269e025fa6703c431e57d8318e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcc269e025fa6703c431e57d8318e58">&#9670;&#160;</a></span>free_index_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_index_arrays </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>arr1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>arr2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e50bafd91246aac8d9f5d32351d29fc" name="a2e50bafd91246aac8d9f5d32351d29fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e50bafd91246aac8d9f5d32351d29fc">&#9670;&#160;</a></span>free_ll_words_holder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_ll_words_holder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Free"></a>
memory allocated in set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> </td></tr>
  </table>
  </dd>
</dl>
<p>store pointer to the previous node</p>
<p>Move to the previous node for the next iteration</p>

</div>
</div>
<a id="a4fcac208c915bad7778b99646abee175" name="a4fcac208c915bad7778b99646abee175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcac208c915bad7778b99646abee175">&#9670;&#160;</a></span>get_current_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * get_current_date </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Function"></a>
to calculate UFP6 representation of all words and store in</h4>
<dl class="section return"><dt>Returns</dt><dd>current date ex: "21/09/2023" </dd></dl>
<p>Format date</p>

</div>
</div>
<a id="a48fd120d3c85ac8b3a167268cb243794" name="a48fd120d3c85ac8b3a167268cb243794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fd120d3c85ac8b3a167268cb243794">&#9670;&#160;</a></span>insert_element_to_AD_in_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_element_to_AD_in_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ad_holder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>s1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>s2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last_date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad_holder</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> struct </td></tr>
    <tr><td class="paramname">set1</td><td>- pointer to set of matrix with words and ufp6 </td></tr>
    <tr><td class="paramname">set2</td><td>- pointer to set of matrix with words and ufp6 </td></tr>
    <tr><td class="paramname">last_date</td><td>- last update date of both sets</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<h4><a class="anchor" id="function"></a>
uses binary search to search for the position in AD where</h4>
<p>new element will be inserted and adjusts the position of the other elements in AD before inserting, when array is full double the size of Dynamic Array </p>
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>Shift elements O(N) , realloc O(N) , binary_search function O(Dlog(N)) D = size of date N = num of elements in Dynamic array </p>
<p>Check if date is valid</p>
<p>Double the size when array is full</p>
<p>Search for position to insert in Dynamic array using Bsearch</p>

</div>
</div>
<a id="ad420b5fa51d69b63d828464f002a810a" name="ad420b5fa51d69b63d828464f002a810a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad420b5fa51d69b63d828464f002a810a">&#9670;&#160;</a></span>insert_element_to_index_AD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_element_to_index_AD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ad_holder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last_date</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<p>insert at position equal or greater than DA size, double the size of array if ad is full doubles the size of ad </p>
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>with the values passed to the function </p>
<h4><a class="anchor" id="Time"></a>
complexity : O(2N + D)) ,</h4>
<p>Shifting elements O(N) , realloc O(N) , insertion O(1), strcpy date O(D) D = date size N = size of elements in dynamic array Extra space : O(1) (inplace) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad_holder</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">set1</td><td>- pointer to set of matrix with words and ufp6 </td></tr>
    <tr><td class="paramname">set2</td><td>- pointer to set of matrix with words and ufp6 </td></tr>
    <tr><td class="paramname">last_date</td><td>- last update date of both sets </td></tr>
    <tr><td class="paramname">index</td><td>- index where new element should be added in the Dynamic array</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>with the values passed to the function </p>
<h4><a class="anchor" id="This"></a>
function encodes a word into an array , using pre-computed UFP6 dictionary and</h4>
<p>Shift elements O(N) , realloc O(N) , insertion O(1), strcpy date O(D) D = date size N = size of elements in dynamic array </p>
<p>Check if date is valid</p>
<p>Double the size when array is full or when index to be inserted is equal or greater than ad_holder size</p>
<p>Shift elements from count until given index to insert new element</p>
<p>Copy from next to prev element</p>
<p>Insert element in Dynamic Array</p>

</div>
</div>
<a id="a03a3269522c2476a05cd9615866d91d0" name="a03a3269522c2476a05cd9615866d91d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a3269522c2476a05cd9615866d91d0">&#9670;&#160;</a></span>insert_node_ll_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_node_ll_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last_date</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<p>Time Complexity: O(N - 1) N = size of nodes in LL Extra space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">set1</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">set2</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">last_date</td><td>- pointer to string containing the last update date </td></tr>
    <tr><td class="paramname">index</td><td>- index to insert new node </td></tr>
  </table>
  </dd>
</dl>
<p>If LL is empty</p>
<p>Use pointer to last node in <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> so don't need to traverse linked list</p>

</div>
</div>
<a id="a98c48d28da0082808cf75bee2f67183e" name="a98c48d28da0082808cf75bee2f67183e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c48d28da0082808cf75bee2f67183e">&#9670;&#160;</a></span>insert_node_ll_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_node_ll_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last_date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<p>in DESC order Time Complexity: O(N) N = size of nodes in LL Extra space: O(1) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">set1</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">set2</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">last_date</td><td>- pointer to string containing the last update date </td></tr>
  </table>
  </dd>
</dl>
<p>If LL is empty</p>
<p>Add to head</p>
<p>Point ll-&gt;ptail to ll-&gt;phead</p>
<p>Search for position using binary search to insert in chronological order</p>
<p>Find current and prev position to add node in chronological order DESC</p>

</div>
</div>
<a id="ad755b423216e7d87aca5766efa3581f5" name="ad755b423216e7d87aca5766efa3581f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad755b423216e7d87aca5766efa3581f5">&#9670;&#160;</a></span>insert_to_ll_given_pointers_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_to_ll_given_pointers_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last_date</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>curr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>prev</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to Linked List Words Holder </td></tr>
    <tr><td class="paramname">set1</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">set2</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">last_date</td><td>- pointer to string containing </td></tr>
    <tr><td class="paramname">curr</td><td>- pointer to current node </td></tr>
    <tr><td class="paramname">prev</td><td>- pointer to previous node </td></tr>
  </table>
  </dd>
</dl>
<p>Insert to tail</p>
<p>point prev node to new node</p>
<p>point ptail to new node</p>
<p>point new node to previous node</p>
<p>point new node to NULL</p>
<p>Add to head</p>
<p>point head to new node</p>
<p>point current node to new node</p>
<p>point new node to current</p>
<p>point new node to NULL</p>
<p>Add between nodes</p>
<p>point previous node to new node</p>
<p>point new node to current</p>
<p>point current node to new node</p>
<p>point new node to pos node</p>

</div>
</div>
<a id="a5aa2f227391b79ff68927556158f649e" name="a5aa2f227391b79ff68927556158f649e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa2f227391b79ff68927556158f649e">&#9670;&#160;</a></span>insert_to_VAL_AD_WORDS_HOLDER()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_to_VAL_AD_WORDS_HOLDER </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html">VAL_AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>val_ad_words_holder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>last_date</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val_ad_words_holder</td><td>- </td></tr>
    <tr><td class="paramname">set1</td><td>- </td></tr>
    <tr><td class="paramname">set2</td><td>- </td></tr>
    <tr><td class="paramname">last_date</td><td>-</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="Insert"></a>
words and their ufp6 representation at the end of both matrix</h4>

</div>
</div>
<a id="adf5e1c549ad8937313509a2f0fb928ad" name="adf5e1c549ad8937313509a2f0fb928ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5e1c549ad8937313509a2f0fb928ad">&#9670;&#160;</a></span>is_valid_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_valid_date </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>date_str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Check"></a>
if word is supported in UFP6</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>- pointer to string holding date </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- </dd></dl>
<p>Using strptime function to check if date_str is valid strptime returns pointer to NULL if date can't be parsed (wrong format)</p>
<p>Valid date</p>

</div>
</div>
<a id="aa78c10e000115e85f60876f2af4b4e15" name="aa78c10e000115e85f60876f2af4b4e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78c10e000115e85f60876f2af4b4e15">&#9670;&#160;</a></span>ll_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> * ll_init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Initialize"></a>
SETS struct</h4>
<dl class="section return"><dt>Returns</dt><dd>pointer to dynamically allocated <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> struct </dd></dl>

</div>
</div>
<a id="a2850f9ea5edc9b80de7297df4192e402" name="a2850f9ea5edc9b80de7297df4192e402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2850f9ea5edc9b80de7297df4192e402">&#9670;&#160;</a></span>main_functions_2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main_functions_2 </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a924b6d1c00255ce25ab589cf606b350d" name="a924b6d1c00255ce25ab589cf606b350d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924b6d1c00255ce25ab589cf606b350d">&#9670;&#160;</a></span>print_AD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_AD </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ad</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a524383b327a0dcba8a84ee33395c3d" name="a7a524383b327a0dcba8a84ee33395c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a524383b327a0dcba8a84ee33395c3d">&#9670;&#160;</a></span>print_ll_words_holder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_ll_words_holder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to Linked List LL_Words_Holder </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4594e078b38fc000a4655a5460c3b7a1" name="a4594e078b38fc000a4655a5460c3b7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4594e078b38fc000a4655a5460c3b7a1">&#9670;&#160;</a></span>print_words_found()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_words_found </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>arr</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index_set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index_set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_ad</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad_holder</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> struct </td></tr>
    <tr><td class="paramname">index_set1</td><td>- pointer to array with index of words found in set1 ///in first position of array store the count of indexes to use inside this function </td></tr>
    <tr><td class="paramname">index_set2</td><td>- pointer to array with index of words found in set2 ///in first position of array store the count of indexes to use inside this function </td></tr>
    <tr><td class="paramname">index_ad</td><td>- index of ad where we found the words </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cee816275b5da6ee477ada2db2c4b47" name="a7cee816275b5da6ee477ada2db2c4b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cee816275b5da6ee477ada2db2c4b47">&#9670;&#160;</a></span>print_words_found_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_words_found_ll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index_set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>index_set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Print"></a>
arr holding words sizes</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to Linked List Words Holder </td></tr>
    <tr><td class="paramname">index_set1</td><td>- pointer to array holding the indices of rows from set1 and at pos 0 of array store the size of indices </td></tr>
    <tr><td class="paramname">index_set2</td><td>- pointer to array holding the indices of rows from set2 and at pos 0 of array store the size of indices </td></tr>
    <tr><td class="paramname">j</td><td>- index of node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7177155ce7ef862f4010f0b4143c5c3e" name="a7177155ce7ef862f4010f0b4143c5c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7177155ce7ef862f4010f0b4143c5c3e">&#9670;&#160;</a></span>read_binfile_to_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_binfile_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>Read size of words from file</p>
<p>Read set of words</p>
<p>Read ufp6 from set</p>

</div>
</div>
<a id="a6c4ea21ee52262e16f2feb81269232eb" name="a6c4ea21ee52262e16f2feb81269232eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4ea21ee52262e16f2feb81269232eb">&#9670;&#160;</a></span>read_binfile_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_binfile_words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>Read word size to set</p>
<p>Allocate memory for each row</p>
<p>Read each char to matrix</p>

</div>
</div>
<a id="aea60e529a5df540b68b2531f8aea9c33" name="aea60e529a5df540b68b2531f8aea9c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea60e529a5df540b68b2531f8aea9c33">&#9670;&#160;</a></span>read_from_bin_to_ad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_bin_to_ad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> **</td>          <td class="paramname"><span class="paramname"><em>ad</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
    <tr><td class="paramname">flag</td><td>- if set to 1 read in chronological order ASC </td></tr>
  </table>
  </dd>
</dl>
<p>Read size of elements from file and initialize dynamic array</p>
<p>Read last update date</p>
<p>Insert to Dynamic Array in chronological order ASC if set to 1</p>

</div>
</div>
<a id="a6bbd8b79b8cfdbccbf580afe9b2dcf56" name="a6bbd8b79b8cfdbccbf580afe9b2dcf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bbd8b79b8cfdbccbf580afe9b2dcf56">&#9670;&#160;</a></span>read_from_binfile_to_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_binfile_to_ll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">fpn-</td><td>file name </td></tr>
    <tr><td class="paramname">flag</td><td>- if set to 1 read in chronological order DESC </td></tr>
  </table>
  </dd>
</dl>
<p>Read number of nodes</p>
<p>Read last update date</p>
<p>Read length of Date</p>
<p>Read Date</p>
<p>Read in chronological order DESC if set to 1</p>

</div>
</div>
<a id="aac44da663698d772b30126ad06a41d86" name="aac44da663698d772b30126ad06a41d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac44da663698d772b30126ad06a41d86">&#9670;&#160;</a></span>read_from_txt_to_ad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_txt_to_ad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> **</td>          <td class="paramname"><span class="paramname"><em>ad</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<p>File format: Number of elements: 1 Index 0 Last Update Date: 2022-11-24 Words set: 1 number_words = 5 3-f o G 2-R Q 5-V U c f T 2-p Z 6-E a 5 0 D j <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a>: 15-1 1 1 1 1 1 0 0 0 1 0 1 0 1 0 12-1 1 0 1 0 1 1 1 0 1 0 0 26-1 1 1 0 0 1 1 1 1 0 0 0 1 1 0 0 1 1 1 1 1 1 0 1 1 1 11-1 1 0 0 1 1 1 1 1 0 1 25-1 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 1 1 0 0 1 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad</td><td>- address of a pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
    <tr><td class="paramname">flag</td><td>- if set to 1 read in chronological order ASC </td></tr>
  </table>
  </dd>
</dl>
<p>Read size of elements from file and initialize dynamic array</p>
<p>%*[^:]%*[:] = read until : to void and after read : to void</p>
<p>Read line to void</p>
<p>Read last update date</p>
<p>Read in chronological order ASC if set to 1</p>

</div>
</div>
<a id="ab5353eb78bf739efca75cf1e8aa84d81" name="ab5353eb78bf739efca75cf1e8aa84d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5353eb78bf739efca75cf1e8aa84d81">&#9670;&#160;</a></span>read_from_txt_to_ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_txt_to_ll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<p>File format: Number of nodes: 1 Node 0 Last Update Date: 2024-01-15 Words set: 1 number_words = 5 3-n h m 2-p x 2-S 4 4-Y G 6 F 4-Z V Q d <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a>: 15-1 0 1 1 1 1 0 0 0 1 1 0 1 1 0 11-1 1 0 0 1 1 0 0 0 0 1 9-1 1 0 1 1 0 1 0 0 21-1 1 1 1 0 0 1 0 1 0 1 0 1 1 0 1 0 1 0 0 1 22-1 1 1 1 0 1 1 1 1 0 0 1 1 1 0 1 0 0 1 1 0 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
    <tr><td class="paramname">flag</td><td>- if set to 1 read in chronological order DESC </td></tr>
  </table>
  </dd>
</dl>
<p>%*[^:]%*[:] = read until : to void and after read : to void</p>
<p>Read line to void</p>
<p>Read last update date</p>
<p>Read in chronological order DESC if set to 1</p>

</div>
</div>
<a id="a0c97b1938ca040f863091df7798ab4f2" name="a0c97b1938ca040f863091df7798ab4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c97b1938ca040f863091df7798ab4f2">&#9670;&#160;</a></span>read_txt_to_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_txt_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>read rowsize from file</p>
<p>Initialize set</p>
<p>Read set of words</p>
<p>Read UFP from set</p>

</div>
</div>
<a id="a1837fce597c7d37e0997b0bb574e1d9b" name="a1837fce597c7d37e0997b0bb574e1d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1837fce597c7d37e0997b0bb574e1d9b">&#9670;&#160;</a></span>read_txt_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_txt_words </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<p>to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>Allocate memory for each row to store word in matrix given size</p>

</div>
</div>
<a id="a08ccad969ddb8710274e2b0a33431aa9" name="a08ccad969ddb8710274e2b0a33431aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ccad969ddb8710274e2b0a33431aa9">&#9670;&#160;</a></span>read_ufp6_binfile_to_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_ufp6_binfile_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>Read size of <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation</p>
<p>allocate for each row size of columns read from file</p>

</div>
</div>
<a id="acdc6876e44f60aa05c0454310df5db94" name="acdc6876e44f60aa05c0454310df5db94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc6876e44f60aa05c0454310df5db94">&#9670;&#160;</a></span>read_ufp6_file_to_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_ufp6_file_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Read"></a>
words from .txt file to set</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>read <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a>: to void</p>
<p>Read size of <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation</p>
<p>allocate for each row size of columns read from file</p>
<p>Read <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation to set</p>

</div>
</div>
<a id="a3732fee5827012efb0e5c622364e1c29" name="a3732fee5827012efb0e5c622364e1c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3732fee5827012efb0e5c622364e1c29">&#9670;&#160;</a></span>realloc_AD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void realloc_AD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ad_holder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Double the size when array is full while inserting in ad, halve the size when array is one-quarterfull while removing element from ad. </p>
<h4><a class="anchor" id="Realloc"></a>
dynamic array</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad_holder</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">size</td><td>- size to reallocate the dynamic array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b51624ce0b6c67e56df1b3365b0f5ea" name="a5b51624ce0b6c67e56df1b3365b0f5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b51624ce0b6c67e56df1b3365b0f5ea">&#9670;&#160;</a></span>save_both_sets_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void save_both_sets_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>s1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>s2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Save"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">s2</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer to the file where data will be inserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a088315e2ec8b05049380f37cd3754bb9" name="a088315e2ec8b05049380f37cd3754bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088315e2ec8b05049380f37cd3754bb9">&#9670;&#160;</a></span>save_set_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int save_set_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Save"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">filename</td><td>- pointer to string containing the file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ae35b56f2ce3abd503218a14de8a2e6" name="a5ae35b56f2ce3abd503218a14de8a2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae35b56f2ce3abd503218a14de8a2e6">&#9670;&#160;</a></span>search_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * search_word </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>word</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Find"></a>
median between arr[lo], arr[mid] and arr[hi]</h4>
<p>Time Complexity: O(N) Extra Space: O(N) N = size of words in set </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">word</td><td>- pointer to a string containing the word to be found </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if word is found in set return a pointer to an array containing the index of rows containing each word from given set and index of Dynamic array and at pos 0 it stores the size of indexes stored in array If the word is not found, return a pointer to NULL </dd></dl>
<p>Start in index 1 to store in index 0 the count of words found in set</p>
<p>Store in pos 0 of array the count of words found in set</p>
<p>if found words return pointer to array</p>

</div>
</div>
<a id="a667e6596e889c9b019e2907d867f1235" name="a667e6596e889c9b019e2907d867f1235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667e6596e889c9b019e2907d867f1235">&#9670;&#160;</a></span>sets_struct_init_v2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sets_struct_init_v2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_words</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Initialise"></a>
set while reading data from file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">num_words</td><td>- size of words in both matrix</td></tr>
  </table>
  </dd>
</dl>
<p>Function to initialize set while reading from file </p>
<p>Initialise array to hold each word size</p>
<p>Initialise array to hold each <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> size</p>
<p>Initialize matrix words and <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> to num_words pointers</p>

</div>
</div>
<a id="a8624201ed5c310a5aaf37fbb67a654d0" name="a8624201ed5c310a5aaf37fbb67a654d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8624201ed5c310a5aaf37fbb67a654d0">&#9670;&#160;</a></span>write_ad_to_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_ad_to_bin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ad</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> struct </td></tr>
    <tr><td class="paramname">fn</td><td>- file name </td></tr>
  </table>
  </dd>
</dl>
<p>Write size of elements in dynamic array</p>
<p>Write both sets inside each index</p>

</div>
</div>
<a id="a0edc6611867bd1fc8e590887bbe5f95d" name="a0edc6611867bd1fc8e590887bbe5f95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edc6611867bd1fc8e590887bbe5f95d">&#9670;&#160;</a></span>write_ad_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_ad_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html">AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ad</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>File format: Number of elements: 1 Index 0 Last Update Date: 2022-11-24 Words set: 1 number_words = 5 3-f o G 2-R Q 5-V U c f T 2-p Z 6-E a 5 0 D j <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a>: 15-1 1 1 1 1 1 0 0 0 1 0 1 0 1 0 12-1 1 0 1 0 1 1 1 0 1 0 0 26-1 1 1 0 0 1 1 1 1 0 0 0 1 1 0 0 1 1 1 1 1 1 0 1 1 1 11-1 1 0 0 1 1 1 1 1 0 1 25-1 0 1 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 1 1 0 0 1 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ad</td><td>- pointer to <a class="el" href="struct_a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Dynamic array of VAL_AD_WORDS_HOLDER.">AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">fn</td><td>- file name </td></tr>
  </table>
  </dd>
</dl>
<p>Write size of elements in dynamic array</p>
<p>Write index of ad</p>
<p>Write both sets inside each index</p>

</div>
</div>
<a id="a5623bed6440cc637ff0749904079a2d2" name="a5623bed6440cc637ff0749904079a2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5623bed6440cc637ff0749904079a2d2">&#9670;&#160;</a></span>write_both_sets_to_binfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_both_sets_to_binfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html">WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>wordsHolder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write both Sets to bin file. </p>
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wordsHolder</td><td>- pointer to <a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html" title="Struct holding 2 sets.">WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed4d2fd78407125fb4f66884563ef62d" name="aed4d2fd78407125fb4f66884563ef62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4d2fd78407125fb4f66884563ef62d">&#9670;&#160;</a></span>write_both_sets_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_both_sets_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html">WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>wordsHolder</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wordsHolder</td><td>- pointer to <a class="el" href="struct_w_o_r_d_s___h_o_l_d_e_r.html" title="Struct holding 2 sets.">WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c3e7d3980db8cf1a7c76e10ca506982" name="a1c3e7d3980db8cf1a7c76e10ca506982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3e7d3980db8cf1a7c76e10ca506982">&#9670;&#160;</a></span>write_index_array_ufp6_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_index_array_ufp6_to_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>index_array</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>of words in matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
    <tr><td class="paramname">index_set1</td><td>- pointer to array containing the indices of words found in set at given index and at pos 0 store the size of indices in array </td></tr>
    <tr><td class="paramname">r</td><td>- row index of word in matrix from <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4caae196df0cb947b4d52622b8823803" name="a4caae196df0cb947b4d52622b8823803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4caae196df0cb947b4d52622b8823803">&#9670;&#160;</a></span>write_index_array_words_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_index_array_words_to_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>index_array</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>given array holding indices of words </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
    <tr><td class="paramname">index_set1</td><td>- pointer to array containing the indices of words found in set at given index and at pos 0 store the size of indices in array </td></tr>
  </table>
  </dd>
</dl>
<p>count of indexes from the words found in set stored in first position of array</p>

</div>
</div>
<a id="a75834cc1e4d38024c9940123c923acbb" name="a75834cc1e4d38024c9940123c923acbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75834cc1e4d38024c9940123c923acbb">&#9670;&#160;</a></span>write_ll_to_binfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_ll_to_binfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> struct </td></tr>
    <tr><td class="paramname">fn</td><td>- file name </td></tr>
  </table>
  </dd>
</dl>
<p>Write size of elements in dynamic array</p>
<p>Pointer to traverse the ll from head to tail</p>
<p>Write index of ad</p>
<p>Write both sets inside each index</p>

</div>
</div>
<a id="a07b9cb10200cfc6a6d4bd10210dd03f6" name="a07b9cb10200cfc6a6d4bd10210dd03f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b9cb10200cfc6a6d4bd10210dd03f6">&#9670;&#160;</a></span>write_ll_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_ll_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html">LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>ll</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fn</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>File format: Number of nodes: 1 Node 0 Last Update Date: 2024-01-15 Words set: 1 number_words = 5 3-n h m 2-p x 2-S 4 4-Y G 6 F 4-Z V Q d <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a>: 15-1 0 1 1 1 1 0 0 0 1 1 0 1 1 0 11-1 1 0 0 1 1 0 0 0 0 1 9-1 1 0 1 1 0 1 0 0 21-1 1 1 1 0 0 1 0 1 0 1 0 1 1 0 1 0 1 0 0 1 22-1 1 1 1 0 1 1 1 1 0 0 1 1 1 0 1 0 0 1 1 0 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ll</td><td>- pointer to <a class="el" href="struct_l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Linked List of NODE_LL_WORDS_HOLDER.">LL_WORDS_HOLDER</a> struct </td></tr>
    <tr><td class="paramname">fn</td><td>- file name </td></tr>
  </table>
  </dd>
</dl>
<p>Write size of elements in dynamic array</p>
<p>Pointer to traverse the ll from head to tail</p>
<p>Write index of ad</p>
<p>Write both sets inside each index</p>

</div>
</div>
<a id="a8e1973a6c5c78356d26936fd8a460a06" name="a8e1973a6c5c78356d26936fd8a460a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1973a6c5c78356d26936fd8a460a06">&#9670;&#160;</a></span>write_set_to_binfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_set_to_binfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>write rowsize (size of words in set) to file</p>
<p>Write sizeof each word</p>

</div>
</div>
<a id="a515b3102e44b80d9157e0ba3c64cfdab" name="a515b3102e44b80d9157e0ba3c64cfdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515b3102e44b80d9157e0ba3c64cfdab">&#9670;&#160;</a></span>write_set_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_set_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>Words set: number_words = 5 5 r q m t v 1 n 5 e y w w v 4 l i u k 4 f o m s <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a>: 25 1 1 0 1 1 1 1 0 1 0 1 0 1 1 0 1 1 1 0 1 1 1 1 1 1 5 1 0 1 1 1 27 1 1 1 0 1 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 1 20 1 0 1 0 1 1 0 0 1 0 1 1 1 1 0 1 0 1 0 0 19 1 1 1 1 1 1 0 0 0 1 0 1 1 0 1 1 1 0 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to set </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer to the file where data will be inserted </td></tr>
  </table>
  </dd>
</dl>
<p>write rowsize (size of words in set) to file</p>

</div>
</div>
<a id="af0a34511a531c457034f83c0b157d22d" name="af0a34511a531c457034f83c0b157d22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a34511a531c457034f83c0b157d22d">&#9670;&#160;</a></span>write_set_ufp6_to_binfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_set_ufp6_to_binfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer </td></tr>
  </table>
  </dd>
</dl>
<p>Write size of <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a> representation</p>

</div>
</div>
<a id="a3c2a06ffe7e28a7e569955f95abd4fb0" name="a3c2a06ffe7e28a7e569955f95abd4fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a06ffe7e28a7e569955f95abd4fb0">&#9670;&#160;</a></span>write_set_ufp6_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_set_ufp6_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>fp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>Format: <a class="el" href="struct_u_f_p6.html" title="Hash table.">UFP6</a>: 25 1 1 0 1 1 1 1 0 1 0 1 0 1 1 0 1 1 1 0 1 1 1 1 1 1 5 1 0 1 1 1 27 1 1 1 0 1 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 1 1 1 1 1 20 1 0 1 0 1 1 0 0 1 0 1 1 1 1 0 1 0 1 0 0 19 1 1 1 1 1 1 0 0 0 1 0 1 1 0 1 1 1 0 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">fp</td><td>- file pointer to the file where data will be inserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47246c505c8e816fc6d569a973397935" name="a47246c505c8e816fc6d569a973397935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47246c505c8e816fc6d569a973397935">&#9670;&#160;</a></span>write_words_found_in_da_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_words_found_in_da_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html">VAL_AD_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>val_ad</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>index_set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>index_set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_ad</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>with given arrays holding the indexes of all words found in each set at a given index and at pos 0 of both arrays store the count of words to use in this function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val_ad</td><td>- pointer to <a class="el" href="struct_v_a_l___a_d___w_o_r_d_s___h_o_l_d_e_r.html" title="Struct holding last_update date and WORDS_HOLDER struct.">VAL_AD_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">index_set1</td><td>- pointer to array containing the indices of words found in set1 at given index of dynamic array </td></tr>
    <tr><td class="paramname">index_set2</td><td>- pointer to array containing the indices of words found in set2 at given index of dynamic array </td></tr>
    <tr><td class="paramname">filename</td><td>- pointer to string containing filename </td></tr>
    <tr><td class="paramname">index_ad</td><td>- index of dynamic array where words were found </td></tr>
  </table>
  </dd>
</dl>
<p>if found words in set1 or set2</p>
<p>if found words in set1</p>
<p>if found words in set2</p>

</div>
</div>
<a id="ab96cd9754599ef28606eb9a7ba3b9d12" name="ab96cd9754599ef28606eb9a7ba3b9d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96cd9754599ef28606eb9a7ba3b9d12">&#9670;&#160;</a></span>write_words_found_in_ll_to_txt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_words_found_in_ll_to_txt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html">NODE_LL_WORDS_HOLDER</a> *</td>          <td class="paramname"><span class="paramname"><em>current</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>index_set1</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>index_set2</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_ll</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<p>with given arrays holding the indexes of all words found in each set at a given node, and at pos 0 of both arrays store the count of words to use in this function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>- pointer to current <a class="el" href="struct_n_o_d_e___l_l___w_o_r_d_s___h_o_l_d_e_r.html" title="Node of LL_WORDS_HOLDER.">NODE_LL_WORDS_HOLDER</a> </td></tr>
    <tr><td class="paramname">index_set1</td><td>- pointer to array containing the indices of words found in set1 at given node from LL and at pos 0 of array the size of indices </td></tr>
    <tr><td class="paramname">index_set2</td><td>- pointer to array containing the indices of words found in set2 at given node from LL and at pos 0 of array the size of indices </td></tr>
    <tr><td class="paramname">filename</td><td>- pointer to string containing filename </td></tr>
    <tr><td class="paramname">index_ll</td><td>- index of LL (node) where words were found </td></tr>
  </table>
  </dd>
</dl>
<p>If found words in set1 or set2</p>
<p>If found words in set1</p>
<p>if found words in set2</p>

</div>
</div>
<a id="a1493e5ee98877a7d6baefa2006b2f7ee" name="a1493e5ee98877a7d6baefa2006b2f7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1493e5ee98877a7d6baefa2006b2f7ee">&#9670;&#160;</a></span>write_words_found_to_txt_set_with_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_words_found_to_txt_set_with_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s_e_t_s.html">SETS</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>array_index_words_found_set</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<h4><a class="anchor" id="Write"></a>
set to txt file</h4>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>- pointer to <a class="el" href="struct_s_e_t_s.html" title="sets struct">SETS</a> struct </td></tr>
    <tr><td class="paramname">filename</td><td>- pointer to string containing file name </td></tr>
    <tr><td class="paramname">array_index_words_found_set</td><td>- array holding indexes of words from set with pattern , in first pos of array it stores the size of words found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
